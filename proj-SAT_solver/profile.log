FUNCTION  neosnippet#helpers#get_filetype()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                              " context_filetype.vim installation check.
    2              0.000005   if !exists('s:exists_context_filetype')
                                silent! call context_filetype#version()
                                let s:exists_context_filetype = exists('*context_filetype#version')
                              endif
                            
    2              0.000008   let context_filetype = s:exists_context_filetype ? context_filetype#get_filetype() : &filetype
    2              0.000004   if context_filetype == ''
                                let context_filetype = 'nothing'
                              endif
                            
    2              0.000002   return context_filetype

FUNCTION  neomake#utils#LoudMessage()
Called 2 times
Total time:   0.000130
 Self time:   0.000014

count  total (s)   self (s)
    2   0.000130   0.000013     call call('neomake#utils#LogMessage', [2] + a:000)

FUNCTION  <SNR>62_get_sources_filetypes()
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000024   let filetypes = exists('*context_filetype#get_filetypes') ?   context_filetype#get_filetypes(a:filetype) : split(((a:filetype == '') ? 'nothing' : a:filetype), '\.')
    2              0.000005   return ['_'] + filetypes

FUNCTION  <SNR>18_is_forbidden()
Called 26 times
Total time:   0.015580
 Self time:   0.001082

count  total (s)   self (s)
   26   0.000583   0.000268   if s:is_excluded_ft(&filetype)
                                return 1
                              endif
   26   0.000931   0.000155   if !s:get('excluded_regions_enabled')
                                return 0
                              endif
   26   0.012916   0.000183   let region = s:get_syn_name()
   26   0.000949   0.000276   return index(s:get('excluded_regions_list'), region) >= 0

FUNCTION  neomake#MakeHandler()
Called 94 times
Total time:   0.136637
 Self time:   0.012321

count  total (s)   self (s)
   94              0.000530     if !has_key(s:jobs, a:job_id)
                                    call neomake#utils#QuietMessage( 'neomake#MakeHandler: '.a:event_type.': job not found: ' . string(a:job_id))
                                    return
                                endif
   94              0.000278     let jobinfo = s:jobs[a:job_id]
   94              0.000154     let maker = jobinfo.maker
   94   0.007037   0.001120     call neomake#utils#DebugMessage(printf('%s: %s: %s', a:event_type, maker.name, string(a:data)), jobinfo)
   94              0.000284     if index(['stdout', 'stderr'], a:event_type) >= 0
   92              0.000268         let last_event_type = get(jobinfo, 'event_type', a:event_type)
   92              0.000161         let jobinfo.event_type = a:event_type
                            
                                    " a:data is a list of 'lines' read. Each element *after* the first
                                    " element represents a newline.
   92              0.000159         if has_key(jobinfo, a:event_type)
   90              0.000162             let lines = jobinfo[a:event_type]
                                        " As per https://github.com/neovim/neovim/issues/3555
   90              0.001795             let jobinfo[a:event_type] = lines[:-2] + [lines[-1] . get(a:data, 0, '')] + a:data[1:]
   90              0.000058         else
    2              0.000005             let jobinfo[a:event_type] = a:data
    2              0.000001         endif
                            
   92              0.000203         if !maker.buffer_output || last_event_type !=# a:event_type
                                        let lines = jobinfo[a:event_type][:-2]
                                        if len(lines)
                                            call s:RegisterJobOutput(jobinfo, lines, a:event_type)
                                        endif
                                        let jobinfo[a:event_type] = jobinfo[a:event_type][-1:]
                                    endif
   92              0.000088     elseif a:event_type ==# 'exit'
                                    " Handle any unfinished lines from stdout/stderr callbacks.
    6              0.000009         for event_type in ['stdout', 'stderr']
    4              0.000007             if has_key(jobinfo, event_type)
    2              0.000004                 let lines = jobinfo[event_type]
    2              0.000003                 if len(lines)
    2              0.000004                     if lines[-1] ==# ''
    2              0.000005                         call remove(lines, -1)
    2              0.000001                     endif
    2              0.000002                     if len(lines)
    2   0.118015   0.000037                         call s:RegisterJobOutput(jobinfo, lines, event_type)
    2              0.000001                     endif
    2              0.000001                 endif
    2              0.000001             endif
    4              0.000003         endfor
                            
    2              0.000004         let status = a:data
    2              0.000004         if has_key(maker, 'exit_callback')
                                        let callback_dict = { 'status': status, 'name': maker.name, 'has_next': has_key(maker, 'next') }
                                        if type(maker.exit_callback) == type('')
                                            let l:ExitCallback = function(maker.exit_callback)
                                        else
                                            let l:ExitCallback = maker.exit_callback
                                        endif
                                        try
                                            call l:ExitCallback(callback_dict)
                                        catch /^Vim\%((\a\+)\)\=:E117/
                                        endtry
                                    endif
    2   0.000151   0.000015         call s:CleanJobinfo(jobinfo)
    2   0.000013   0.000005         if neomake#has_async_support()
    2   0.000130   0.000013             call neomake#utils#DebugMessage(printf( '%s: completed with exit code %d.', maker.name, status), jobinfo)
    2              0.000001         endif
                            
                                    " If signs were not cleared before this point, then the maker did not return
                                    " any errors, so all signs must be removed
    2              0.000002         if maker.file_mode
    2   0.000052   0.000007             call neomake#CleanOldFileSignsAndErrors(jobinfo.bufnr)
    2              0.000001         else
                                        call neomake#CleanOldProjectSignsAndErrors()
                                    endif
                            
                                    " Show the current line's error
    2   0.000086   0.000005         call neomake#EchoCurrentError()
                            
    2              0.000003         if has_key(maker, 'next')
                                        let next_makers = '['.join(maker.next.enabled_makers, ', ').']'
                                        if get(g:, 'neomake_serialize_abort_on_error') && status !=# 0
                                            call neomake#utils#LoudMessage('Aborting next makers '.next_makers)
                                        else
                                            call neomake#utils#DebugMessage(printf('next makers: %s', next_makers), jobinfo)
                                            call s:Make(maker.next, a:job_id)
                                        endif
                                    endif
                            
                                    " Trigger autocmd if all jobs for a s:Make instance have finished.
    2   0.000011   0.000004         if neomake#has_async_support()
    2              0.000008             if !len(filter(copy(s:jobs), 'v:val.make_id == jobinfo.make_id'))
    2   0.000036   0.000009                 call neomake#utils#hook('NeomakeFinished', { 'file_mode': maker.file_mode})
    2              0.000001             endif
    2              0.000001         endif
    2              0.000001     endif

FUNCTION  neomake#Make()
Called 2 times
Total time:   0.006422
 Self time:   0.000134

count  total (s)   self (s)
    2              0.000021     let options = a:0 ? { 'exit_callback': a:1 } : {}
    2              0.000010     let options.file_mode = a:file_mode
    2              0.000009     let options.ft = &filetype
    2   0.000836   0.000048     let options.enabled_makers = len(a:enabled_makers) ? a:enabled_makers : neomake#GetEnabledMakers(a:file_mode ? &filetype : '')
    2   0.005537   0.000037     return s:Make(options)

FUNCTION  neomake#utils#AvailableMakers()
Called 2 times
Total time:   0.000171
 Self time:   0.000049

count  total (s)   self (s)
    2   0.000170   0.000048     return filter(copy(a:makers), 'neomake#utils#MakerIsAvailable(a:ft, v:val)')

FUNCTION  neoinclude#util#get_context_filetype()
Called 22 times
Total time:   0.000369
 Self time:   0.000369

count  total (s)   self (s)
                              " context_filetype.vim installation check.
   22              0.000084   if !exists('s:exists_context_filetype')
                                try
                                  call context_filetype#version()
                                  let s:exists_context_filetype = 1
                                catch
                                  let s:exists_context_filetype = 0
                                endtry
                              endif
                            
   22              0.000076   return s:exists_context_filetype ? context_filetype#get_filetype() : &filetype

FUNCTION  deoplete#util#exists_omnifunc()
Called 22 times
Total time:   0.000608
 Self time:   0.000608

count  total (s)   self (s)
   22              0.000218   if !exists('s:called_omnifuncs')
                                let s:called_omnifuncs = {}
                              endif
                            
   22              0.000070   if !has_key(s:called_omnifuncs, a:name)
                                silent! call {a:name}(1, '')
                                let s:called_omnifuncs[a:name] = exists('*' . a:name)
                              endif
   22              0.000058   return s:called_omnifuncs[a:name]

FUNCTION  neoinclude#get_pattern()
Called 44 times
Total time:   0.001355
 Self time:   0.000554

count  total (s)   self (s)
   44   0.001331   0.000530   return neoinclude#util#get_buffer_config(   a:filetype, 'b:neoinclude_patterns',   g:neoinclude#patterns, g:neoinclude#_patterns,   getbufvar(a:bufnr, '&include'))

FUNCTION  neomake#signs#RegisterSign()
Called 58 times
Total time:   0.000828
 Self time:   0.000828

count  total (s)   self (s)
   58              0.000248     let s:sign_queue[a:type][a:entry.bufnr] = get(s:sign_queue[a:type], a:entry.bufnr, {})
   58              0.000190     let existing = get(s:sign_queue[a:type][a:entry.bufnr], a:entry.lnum, {})
   58              0.000127     if empty(existing) || a:entry.type ==# 'E' && existing.type !=# 'E'
   58              0.000190         let s:sign_queue[a:type][a:entry.bufnr][a:entry.lnum] = a:entry
   58              0.000031     endif

FUNCTION  neosnippet#util#get_cur_text()
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000019   return (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . col('.') . 'c' . (mode() ==# 'i' ? '' : '.'))

FUNCTION  deoplete#custom#get()
Called 24 times
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
   24              0.000123   if !exists('s:custom')
                                let s:custom = {}
                                let s:custom._ = {}
                              endif
                            
   24              0.000042   return s:custom

FUNCTION  deoplete#util#get_input()
Called 70 times
Total time:   0.004483
 Self time:   0.004483

count  total (s)   self (s)
   70              0.000206   let mode = mode()
   70              0.000157   if a:event ==# 'InsertEnter'
                                let mode = 'i'
                              endif
   70              0.001261   let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
   70              0.000819   if input =~ '^.\{-}\ze\S\+$'
   38              0.000352     let complete_str = matchstr(input, '\S\+$')
   38              0.000375     let input = matchstr(input, '^.\{-}\ze\S\+$')
   38              0.000038   else
   32              0.000069     let complete_str = ''
   32              0.000029   endif
                            
   70              0.000145   if a:event ==# 'InsertCharPre'
                                let complete_str .= v:char
                              endif
                            
   70              0.000176   return input . complete_str

FUNCTION  <SNR>45_MakeJob()
Called 2 times
Total time:   0.003629
 Self time:   0.003253

count  total (s)   self (s)
    2              0.000003     let job_id = s:job_id
    2              0.000007     let s:job_id += 1
    2              0.000013     let jobinfo = { 'name': 'neomake_'.job_id, 'winnr': winnr(), 'bufnr': bufnr('%'), 'maker': a:maker, 'make_id': a:make_id, }
                            
                                " Resolve exe/args, which might be a function or dictionary.
    2              0.000008     if type(a:maker.exe) == type(function('tr'))
                                    let exe = call(a:maker.exe, [])
                                elseif type(a:maker.exe) == type({})
                                    let exe = call(a:maker.exe.fn, [], a:maker.exe)
                                else
    2              0.000003         let exe = a:maker.exe
    2              0.000001     endif
    2              0.000006     if type(a:maker.args) == type(function('tr'))
                                    let args = call(a:maker.args, [])
                                elseif type(a:maker.args) == type({})
                                    let args = call(a:maker.args.fn, [], a:maker.args)
                                else
    2              0.000003         let args = a:maker.args
    2              0.000001     endif
    2              0.000010     let append_file = a:maker.file_mode && index(args, '%:p') == -1 && get(a:maker, 'append_file', 1)
    2              0.000002     if append_file
    2              0.000005         call add(args, '%:p')
    2              0.000001     endif
                            
    2   0.000115   0.000010     call neomake#utils#ExpandArgs(args)
                            
    2              0.000005     if has_key(a:maker, 'cwd')
                                    let old_wd = getcwd()
                                    let cwd = expand(a:maker.cwd, 1)
                                    exe 'cd' fnameescape(cwd)
                                endif
                            
    2              0.000002     try
    2              0.000006         let has_args = type(args) == type([])
    2              0.000002         let error = ''
    2   0.000020   0.000010         if neomake#has_async_support()
    2              0.000003             let argv = [exe]
    2              0.000002             if has_args
    2              0.000004                 let argv += args
    2              0.000001             endif
    2              0.000004             if has('nvim')
    2              0.000012                 let opts = { 'on_stdout': function('neomake#MakeHandler'), 'on_stderr': function('neomake#MakeHandler'), 'on_exit': function('neomake#MakeHandler') }
    2              0.000002                 try
    2   0.000152   0.000021                     call neomake#utils#LoudMessage(printf( 'Starting async job: %s', string(argv)), jobinfo)
    2              0.002602                     let job = jobstart(argv, opts)
    2              0.000014                 catch
                                                let error = printf('Failed to start Neovim job: %s: %s', string(argv), v:exception)
                                            endtry
    2              0.000011                 if empty(error)
    2              0.000004                     if job == 0
                                                    let error = 'Job table is full or invalid arguments given'
                                                elseif job == -1
                                                    " Never happens?!
                                                    " https://github.com/neovim/neovim/issues/5465
                                                    let error = 'Executable not found'
                                                else
    2              0.000009                         let jobinfo.id = job
    2              0.000022                         let s:jobs[jobinfo.id] = jobinfo
    2              0.000002                     endif
    2              0.000001                 endif
    2              0.000002             else
                                            " vim-async.
                                            let opts = { 'err_cb': 'neomake#MakeHandlerVimStderr', 'out_cb': 'neomake#MakeHandlerVimStdout', 'close_cb': 'neomake#MakeHandlerVimClose', 'mode': 'raw', }
                                            if neomake#utils#IsRunningWindows()
                                                let argv = &shell.' '.&shellcmdflag.' '.shellescape(join(argv))
                                            endif
                                            try
                                                call neomake#utils#LoudMessage(printf( 'Starting async job: %s', string(argv)), jobinfo)
                                                let job = job_start(argv, opts)
                                                " Get this as early as possible!
                                                " XXX: the job might be finished already before the setup
                                                "      is done completely!
                                                let job_status = job_status(job)
                                                let jobinfo.id = ch_info(job)['id']
                                                let jobinfo.vim_job = job
                                                let s:jobs[jobinfo.id] = jobinfo
                                            catch
                                                let error = printf('Failed to start Vim job: %s: %s', argv, v:exception)
                                            endtry
                                            if job_status !=# 'run'
                                                let error = printf('Vim job failed to run: %s', string(job))
                                            endif
                                            if empty(error)
                                                call neomake#utils#DebugMessage(printf('Vim job: %s', string(job_info(job))), jobinfo)
                                                call neomake#utils#DebugMessage(printf('Vim channel: %s', string(ch_info(job))), jobinfo)
                                            endif
                                        endif
                            
                                        " Bail out on errors.
    2              0.000006             if len(error)
                                            call neomake#utils#LoudMessage(error)
                                            return -1
                                        endif
                            
    2   0.000061   0.000038             let maker_key = s:GetMakerKey(a:maker)
    2              0.000009             let s:jobs_by_maker[maker_key] = jobinfo
    2   0.000161   0.000052             call s:AddJobinfoForCurrentWin(jobinfo.id)
    2              0.000004             let r = jobinfo.id
    2              0.000002         else
                                        call neomake#utils#DebugMessage('Running synchronously')
                                        if has_args
                                            if neomake#utils#IsRunningWindows()
                                                let program = exe.' '.join(map(args, 'v:val'))
                                            else
                                                let program = exe.' '.join(map(args, 'shellescape(v:val)'))
                                            endif
                                        else
                                            let program = exe
                                        endif
                            
                                        call neomake#utils#LoudMessage('Starting: ' . program)
                            
                                        let jobinfo.id = job_id
                                        let s:jobs[job_id] = jobinfo
                                        call s:AddJobinfoForCurrentWin(jobinfo.id)
                                        call neomake#MakeHandler(job_id, split(system(program), '\r\?\n', 1), 'stdout')
                                        call neomake#MakeHandler(job_id, v:shell_error, 'exit')
                                        let r = -1
                                    endif
    2              0.000003     finally
    2              0.000005         if exists('old_wd')
                                        exe 'cd' fnameescape(old_wd)
                                    endif
    2              0.000002     endtry
    2              0.000003     return r

FUNCTION  delimitMate#ExpandSpace()
Called 10 times
Total time:   0.007562
 Self time:   0.000506

count  total (s)   self (s)
   10   0.005575   0.000130   if s:is_forbidden("\<Space>")
                                return "\<Space>"
                              endif
   10   0.000821   0.000130   let escaped = s:cursor_idx() >= 2 && s:get_char(-2) == '\'
   10   0.000303   0.000081   let expand_inside_quotes = s:get('expand_inside_quotes')     && s:is_empty_quotes()     && !escaped
   10   0.000754   0.000057   if s:is_empty_matchpair() || expand_inside_quotes
                                " Expand:
                                return "\<Space>\<Space>" . s:joinUndo() . "\<Left>"
                              else
   10              0.000023     return "\<Space>"
                              endif

FUNCTION  <SNR>45_RegisterJobOutput()
Called 2 times
Total time:   0.117978
 Self time:   0.000130

count  total (s)   self (s)
    2              0.000030     let lines = copy(a:lines)
    2              0.000003     let maker = a:jobinfo.maker
                            
    2              0.000004     if !get(maker, 'file_mode')
                                    call s:ProcessJobOutput(a:jobinfo, lines, a:source)
                                    call neomake#signs#PlaceVisibleSigns()
                                    return
                                endif
                            
                                " file mode: append lines to jobs's window's output.
    2   0.000069   0.000011     let [t, w] = s:GetTabWinForJob(a:jobinfo.id)
    2              0.000002     if w == -1
                                    call neomake#utils#LoudMessage('No window found for output!', a:jobinfo)
                                    return
                                endif
    2   0.000030   0.000015     let w_output = s:gettabwinvar(t, w, 'neomake_jobs_output', []) + [{ 'source': a:source, 'jobinfo': a:jobinfo, 'lines': lines }]
    2              0.000009     call settabwinvar(t, w, 'neomake_jobs_output', w_output)
                            
                                " Process the window on demand if we can.
    2   0.000027   0.000013     let idx_win_job = index(s:getwinvar(winnr(), 'neomake_jobs', []), a:jobinfo.id)
    2              0.000002     if idx_win_job != -1
    2   0.117768   0.000007         call neomake#ProcessCurrentWindow()
    2              0.000002     elseif &filetype ==# 'qf'
                                    " Process the previous window if we are in a qf window.
                                    " XXX: noautocmd, restore alt window.
                                    wincmd p
                                    call neomake#ProcessCurrentWindow()
                                    wincmd p
                                endif

FUNCTION  neomake#GetEnabledMakers()
Called 2 times
Total time:   0.000788
 Self time:   0.000489

count  total (s)   self (s)
    2              0.000015     if !a:0 || type(a:1) !=# type('')
                                    " If we have no filetype, use the global default makers.
                                    " This variable is also used for project jobs, so it has no
                                    " buffer local ('b:') counterpart for now.
                                    return get(g:, 'neomake_enabled_makers', [])
                                endif
                            
                                " If a filetype was passed, get the makers that are enabled for each of
                                " the filetypes represented.
    2              0.000005     let makers = []
    2              0.000006     let makers_count = {}
    2   0.000145   0.000059     let fts = neomake#utils#GetSortedFiletypes(a:1)
    4              0.000010     for ft in fts
    2              0.000018         let ft = substitute(ft, '\W', '_', 'g')
    2              0.000005         unlet! l:enabled_makers
    6              0.000024         for l:varname in [ 'b:neomake_'.ft.'_enabled_makers', 'g:neomake_'.ft.'_enabled_makers']
    4              0.000024             if exists(l:varname)
                                            let l:enabled_makers = eval(l:varname)
                                            break
                                        endif
    4              0.000005         endfor
                            
                                    " Use plugin's defaults if not customized.
    2              0.000006         if !exists('l:enabled_makers')
    2              0.000003             try
    2              0.000007                 let fnname = 'neomake#makers#ft#'.ft.'#EnabledMakers'
    2   0.000069   0.000027                 let default_makers = eval(fnname . '()')
    2              0.000004             catch /^Vim\%((\a\+)\)\=:E117/
                                            let default_makers = []
                                        endtry
    2   0.000192   0.000021             let l:enabled_makers = neomake#utils#AvailableMakers(ft, default_makers)
    2              0.000002         endif
                            
                                    " @vimlint(EVL104, 1, l:enabled_makers)
    4              0.000007         for maker_name in l:enabled_makers
    2              0.000009             let c = get(makers_count, maker_name, 0)
    2              0.000008             let makers_count[maker_name] = c + 1
                                        " Add each maker only once, but keep the order.
    2              0.000003             if c == 0
    2              0.000007                 let makers += [maker_name]
    2              0.000002             endif
    2              0.000002         endfor
    2              0.000002     endfor
                            
    2              0.000006     let l = len(fts)
    2              0.000011     return filter(makers, 'makers_count[v:val] ==# l')

FUNCTION  <SNR>18_get_syn_name()
Called 26 times
Total time:   0.012734
 Self time:   0.012734

count  total (s)   self (s)
   26              0.000122   let col = col('.')
   26              0.000075   if  col == col('$')
   18              0.000049     let col = col - 1
   18              0.000019   endif
   26              0.012404   return synIDattr(synIDtrans(synID(line('.'), col, 1)), 'name')

FUNCTION  deoplete#init#_context()
Called 24 times
Total time:   0.033790
 Self time:   0.015864

count  total (s)   self (s)
   24              0.000434   let filetype = (exists('*context_filetype#get_filetype') ?   context_filetype#get_filetype() :   (&filetype == '' ? 'nothing' : &filetype))
   24   0.003599   0.000837   let filetypes = exists('*context_filetype#get_filetypes') ?   context_filetype#get_filetypes() :   &filetype == '' ? ['nothing'] :                     deoplete#util#uniq([&filetype]                          + split(&filetype, '\.'))
                            
   24   0.000525   0.000274   let sources = deoplete#util#convert2list(a:sources)
   24              0.000138   if a:event !=# 'Manual' && empty(sources)
                                " Use default sources
   24   0.001525   0.000322     let sources = deoplete#util#get_buffer_config( filetype, 'b:deoplete_sources', 'g:deoplete#sources', '{}', [])
   24              0.000034   endif
                            
   24   0.001714   0.000481   let keyword_patterns = join(deoplete#util#convert2list(   deoplete#util#get_buffer_config(   filetype, 'b:deoplete_keyword_patterns',   'g:deoplete#keyword_patterns',   'g:deoplete#_keyword_patterns')), '|')
                            
                              " Convert keyword pattern.
   24   0.009042   0.000292   let pattern = deoplete#util#vimoption2python( &l:iskeyword . (&l:lisp ? ',-' : ''))
   24              0.000263   let keyword_patterns = substitute(keyword_patterns, '\\k', '\=pattern', 'g')
                            
   24   0.000307   0.000189   let event = (deoplete#util#get_prev_event() ==# 'Refresh') ? 'Manual' : a:event
                            
   24   0.001867   0.000142   let input = deoplete#util#get_input(a:event)
                            
   24              0.000325   let width = winwidth(0) - col('.') + len(matchstr(input, '\w*$'))
                            
   24   0.013702   0.011818   return { 'changedtick': b:changedtick, 'event': event, 'input': input, 'next_input': deoplete#util#get_next_input(a:event), 'complete_str': '', 'encoding': &encoding, 'position': getpos('.'), 'filetype': filetype, 'filetypes': filetypes, 'ignorecase': g:deoplete#enable_ignore_case, 'smartcase': g:deoplete#enable_smart_case, 'camelcase': g:deoplete#enable_camel_case, 'delay': g:deoplete#auto_complete_delay, 'sources': sources, 'keyword_patterns': keyword_patterns, 'max_abbr_width': (width * 2 / 3), 'max_menu_width': (width * 2 / 3), 'runtimepath': &runtimepath, 'bufnr': bufnr('%'), 'bufname': bufname('%'), 'cwd': getcwd(), 'start_complete': "\<Plug>_", 'vars': filter(copy(g:), "stridx(v:key, 'deoplete#') == 0"), 'bufvars': filter(copy(b:), "stridx(v:key, 'deoplete_') == 0"), 'custom': deoplete#custom#get(), 'omni__omnifunc': &l:omnifunc, 'dict__dictionary': &l:dictionary, }

FUNCTION  neosnippet#helpers#get_snippets()
Called 2 times
Total time:   0.000858
 Self time:   0.000625

count  total (s)   self (s)
    2              0.000018   let mode = get(a:000, 0, mode())
                            
    2   0.000037   0.000020   call neosnippet#init#check()
                            
    2   0.000033   0.000010   let neosnippet = neosnippet#variables#current_neosnippet()
    2              0.000009   let snippets = copy(neosnippet.snippets)
    6   0.000094   0.000028   for filetype in s:get_sources_filetypes(neosnippet#helpers#get_filetype())
    4   0.000112   0.000020     call neosnippet#commands#_make_cache(filetype)
    4   0.000119   0.000103     call extend(snippets, neosnippet#variables#snippets()[filetype])
    4              0.000003   endfor
                            
    2   0.000030   0.000010   let cur_text = neosnippet#util#get_cur_text()
                            
    2              0.000003   if mode ==# 'i' || mode ==# 's'
                                " Special filters.
                                if !s:is_beginning_of_line(cur_text)
                                  call filter(snippets, '!v:val.options.head')
                                endif
                              endif
                            
    2              0.000358   call filter(snippets, "cur_text =~# get(v:val, 'regexp', '')")
                            
    2              0.000006   if exists('b:neosnippet_disable_snippet_triggers')
                                call filter(snippets, "index(b:neosnippet_disable_snippet_triggers, v:val.word) < 0")
                              endif
                            
    2              0.000002   return snippets

FUNCTION  <SNR>60_completion_delayed()
Called 22 times
Total time:   0.041459
 Self time:   0.001416

count  total (s)   self (s)
   22              0.000384   let timer = s:timer
   22              0.000104   unlet! s:timer
   22              0.000119   if b:changedtick == timer.changedtick
   22   0.040717   0.000673     call s:completion_begin(timer.event)
   22              0.000036   endif

FUNCTION  <SNR>45_GetTabWinForJob()
Called 4 times
Total time:   0.000109
 Self time:   0.000075

count  total (s)   self (s)
    4              0.000029     for t in [tabpagenr()] + range(1, tabpagenr()-1) + range(tabpagenr()+1, tabpagenr('$'))
    4              0.000011         for w in range(1, tabpagewinnr(t, '$'))
    4   0.000058   0.000024             if index(s:gettabwinvar(t, w, 'neomake_jobs', []), a:job_id) != -1
    4              0.000005                 return [t, w]
                                        endif
                                    endfor
                                endfor
                                return [-1, -1]

FUNCTION  deoplete#util#uniq()
Called 50 times
Total time:   0.006597
 Self time:   0.006597

count  total (s)   self (s)
   50              0.000847   let list = map(copy(a:list), '[v:val, v:val]')
   50              0.000124   let i = 0
   50              0.000148   let seen = {}
  222              0.000752   while i < len(list)
  172              0.000914     let key = string(list[i][1])
  172              0.000558     if has_key(seen, key)
   26              0.000137       call remove(list, i)
   26              0.000031     else
  146              0.000485       let seen[key] = 1
  146              0.000293       let i += 1
  146              0.000130     endif
  172              0.000190   endwhile
   50              0.000419   return map(list, 'v:val[0]')

FUNCTION  neomake#makers#ft#cpp#clang()
Called 2 times
Total time:   0.000034
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000027   0.000012     let maker = neomake#makers#ft#c#clang()
    2              0.000003     let maker.exe = 'clang++'
    2              0.000002     return maker

FUNCTION  delimitMate#IsEmptyPair()
Called 10 times
Total time:   0.000293
 Self time:   0.000201

count  total (s)   self (s)
   10              0.000100   if strlen(substitute(a:str, ".", "x", "g")) != 2
    8              0.000010     return 0
                              endif
    2   0.000075   0.000025   let idx = index(s:get('left_delims'), matchstr(a:str, '^.'))
    2              0.000011   if idx > -1 && s:get('right_delims')[idx] == matchstr(a:str, '.$')
                                return 1
                              endif
    2   0.000062   0.000020   let idx = index(s:get('quotes_list'), matchstr(a:str, '^.'))
    2              0.000008   if idx > -1 && s:get('quotes_list')[idx] == matchstr(a:str, '.$')
                                return 1
                              endif
    2              0.000002   return 0

FUNCTION  delimitMate#ParenDelim()
Called 2 times
Total time:   0.001902
 Self time:   0.000294

count  total (s)   self (s)
    2   0.000198   0.000055   let left = s:get('left_delims')[index(s:get('right_delims'),a:right)]
    2   0.001248   0.000011   if s:is_forbidden(a:right)
                                return left
                              endif
                              " Try to balance matchpairs
    2   0.000057   0.000016   if s:get('balance_matchpairs') && s:balance_matchpairs(a:right) < 0
                                return left
                              endif
    2              0.000012   let line = getline('.')
    2              0.000007   let col = col('.')-2
    2   0.000050   0.000010   if s:get('smart_matchpairs') != ''
    2   0.000073   0.000036     let smart_matchpairs = substitute(s:get('smart_matchpairs'), '\\!', left, 'g')
    2              0.000017     let smart_matchpairs = substitute(smart_matchpairs, '\\#', a:right, 'g')
    2              0.000031     if line[col+1:] =~ smart_matchpairs
                                  return left
                                endif
    2              0.000002   endif
    2   0.000056   0.000016   if len(line) == (col + 1) && s:get('insert_eol_marker') == 1
    2   0.000046   0.000009     let tail = s:get('eol_marker')
    2              0.000002   else
                                let tail = ''
                              endif
    2   0.000071   0.000038   return left . a:right . tail . repeat(s:joinUndo() . "\<Left>", len(split(tail, '\zs')) + 1)

FUNCTION  <SNR>45_Make()
Called 2 times
Total time:   0.005500
 Self time:   0.000537

count  total (s)   self (s)
    2              0.000009     let file_mode = get(a:options, 'file_mode')
    2              0.000008     let enabled_makers = get(a:options, 'enabled_makers', [])
    2              0.000004     if !len(enabled_makers)
                                    if file_mode
                                        call neomake#utils#DebugMessage('Nothing to make: no enabled makers.')
                                        return []
                                    endif
                                    let enabled_makers = ['makeprg']
                                endif
                            
    2              0.000003     if a:0
                                    let make_id = a:1
                                else
    2              0.000014         let s:make_id += 1
    2              0.000005         let make_id = s:make_id
    2              0.000002     endif
    2   0.000053   0.000018     call neomake#signs#DefineSigns()
                            
    2   0.000202   0.000029     call neomake#utils#DebugMessage(printf('Running makers: %s', string(enabled_makers)), {'make_id': make_id})
                            
    2              0.000005     let buf = bufnr('%')
    2              0.000003     let win = winnr()
    2              0.000005     let ft = get(a:options, 'ft', '')
                            
    2              0.000002     if file_mode
    2   0.000083   0.000012         call neomake#statusline#ResetCountsForBuf(buf)
    2              0.000001     else
                                    call neomake#statusline#ResetCountsForProject()
                                endif
                            
                                " Empty the quickfix/location list (using a valid 'errorformat' setting).
    2              0.000005     let l:efm = &errorformat
    2              0.000002     try
    2              0.000009         let &errorformat = '%-G'
    2              0.000002         if file_mode
    2              0.000018             lgetexpr ''
    2              0.000001         else
                                        cgetexpr ''
                                    endif
    2              0.000002     finally
    2              0.000006         let &errorformat = l:efm
    2              0.000002     endtry
    2   0.000047   0.000017     call s:HandleLoclistQflistDisplay(file_mode)
                            
    2              0.000004     if !get(a:options, 'continuation')
                                    " Only do this if we have one or more enabled makers
    2              0.000002         if file_mode
    2   0.000095   0.000009             call neomake#signs#ResetFile(buf)
    2              0.000006             let s:need_errors_cleaning['file'][buf] = 1
    2              0.000001         else
                                        call neomake#signs#ResetProject()
                                        let s:need_errors_cleaning['project'] = 1
                                    endif
    2              0.000001     endif
                            
    2              0.000007     let serialize = get(g:, 'neomake_serialize')
    2              0.000003     let job_ids = []
    4              0.000007     for name in enabled_makers
    2   0.000945   0.000014         let maker = neomake#GetMaker(name, ft)
    2              0.000003         if empty(maker)
                                        continue
                                    endif
    2              0.000012         call extend(maker, { 'file_mode': file_mode, 'bufnr': buf, 'winnr': win, }, 'error')
    2   0.000020   0.000012         let maker_key = s:GetMakerKey(maker)
    2              0.000005         if has_key(s:jobs_by_maker, maker_key)
                                        let jobinfo = s:jobs_by_maker[maker_key]
                                        let jobinfo.maker.next = copy(a:options)
                                        call neomake#CancelJob(jobinfo.id)
                                        break
                                    endif
    2              0.000004         if serialize && len(enabled_makers) > 1
                                        let next_opts = copy(a:options)
                                        let next_opts.enabled_makers = enabled_makers[1:]
                                        let next_opts.continuation = 1
                                        let maker.next = next_opts
                                    endif
    2              0.000004         if has_key(a:options, 'exit_callback')
                                        let maker.exit_callback = a:options.exit_callback
                                    endif
    2   0.003668   0.000039         let job_id = s:MakeJob(make_id, maker)
    2              0.000006         if job_id != -1
    2              0.000008             call add(job_ids, job_id)
    2              0.000002         endif
                                    " If we are serializing makers, stop after the first one. The
                                    " remaining makers will be processed in turn when this one is done.
    2              0.000003         if serialize
                                        break
                                    endif
    2              0.000002     endfor
    2              0.000005     if !len(job_ids)
                                    call neomake#utils#hook('NeomakeFinished', { 'file_mode': file_mode})
                                endif
    2              0.000006     return job_ids

FUNCTION  <SNR>60_on_event()
Called 2 times
Total time:   0.002524
 Self time:   0.000184

count  total (s)   self (s)
    2   0.002360   0.000020   let context = deoplete#init#_context(a:event, [])
    2              0.000158   call rpcnotify(g:deoplete#_channel_id, 'deoplete_on_event', context)

FUNCTION  neosnippet#handlers#_cursor_moved()
Called 75 times
Total time:   0.001415
 Self time:   0.000867

count  total (s)   self (s)
   75   0.000959   0.000411   let expand_stack = neosnippet#variables#expand_stack()
                            
                              " Get patterns and count.
   75              0.000260   if !&l:modifiable || !&l:modified || empty(expand_stack)
   75              0.000053     return
                              endif
                            
                              let expand_info = expand_stack[-1]
                              if expand_info.begin_line == expand_info.end_line && line('.') != expand_info.begin_line
                                call neosnippet#view#_clear_markers(expand_info)
                              endif

FUNCTION  <SNR>45_ProcessJobOutput()
Called 2 times
Total time:   0.076626
 Self time:   0.010460

count  total (s)   self (s)
    2              0.000003     let maker = a:jobinfo.maker
    2   0.000127   0.000014     call neomake#utils#DebugMessage(printf( '%s: processing %d lines of output.', maker.name, len(a:lines)), a:jobinfo)
                            
    2              0.000003     if has_key(maker, 'mapexpr')
                                    if maker.file_mode
                                        let l:neomake_bufname = bufname(maker.bufnr)
                                        " @vimlint(EVL102, 1, l:neomake_bufdir)
                                        let l:neomake_bufdir = fnamemodify(neomake_bufname, ':h')
                                    endif
                                    " @vimlint(EVL102, 1, l:neomake_output_source)
                                    let l:neomake_output_source = a:source
                                    call map(a:lines, maker.mapexpr)
                                endif
                            
    2              0.000006     let olderrformat = &errorformat
    2              0.000017     let &errorformat = maker.errorformat
    2              0.000002     try
    2              0.000005         let file_mode = get(maker, 'file_mode')
    2              0.000002         if file_mode
    2              0.000004             let prev_list = getloclist(0)
    2              0.010296             laddexpr a:lines
    2              0.000003         else
                                        let prev_list = getqflist()
                                        caddexpr a:lines
                                    endif
    2   0.066025   0.000027         let counts_changed = s:AddExprCallback(a:jobinfo, len(prev_list))
    2              0.000002         if !counts_changed
                                        let counts_changed = (file_mode && getloclist(0) != prev_list) || (!file_mode && getqflist() != prev_list)
                                    endif
    2              0.000002         if counts_changed
    2   0.000041   0.000013             call neomake#utils#hook('NeomakeCountsChanged', { 'file_mode': maker.file_mode, 'bufnr': get(maker, 'bufnr', -1), })
    2              0.000001         endif
    2              0.000002     finally
    2              0.000012         let &errorformat = olderrformat
    2              0.000002     endtry
                            
    2   0.000034   0.000008     call s:HandleLoclistQflistDisplay(maker.file_mode)

FUNCTION  <SNR>17_TriggerAbb()
Called 16 times
Total time:   0.000501
 Self time:   0.000501

count  total (s)   self (s)
   16              0.000284   if v:version < 703 || ( v:version == 703 && !has('patch489') ) || pumvisible()
                                return ''
                              endif
   16              0.000074   return "\<C-]>"

FUNCTION  neomake#makers#ft#cpp#EnabledMakers()
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000040     return executable('clang++') ? ['clang', 'clangtidy', 'clangcheck'] : ['gcc']

FUNCTION  neosnippet#helpers#get_completion_snippets()
Called 2 times
Total time:   0.001110
 Self time:   0.000252

count  total (s)   self (s)
    2   0.001106   0.000248   return filter(neosnippet#helpers#get_snippets(), "!get(v:val.options, 'oneshot', 0)")

FUNCTION  deoplete#util#get_prev_event()
Called 24 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
   24              0.000104   return get(g:deoplete#_context, 'event', '')

FUNCTION  neomake#CleanOldFileSignsAndErrors()
Called 4 times
Total time:   0.049912
 Self time:   0.000137

count  total (s)   self (s)
    4              0.000009     let bufnr = a:0 ? a:1 : bufnr('%')
    4              0.000013     if get(s:need_errors_cleaning['file'], bufnr, 0)
    2              0.000005         if has_key(s:current_errors['file'], bufnr)
    2              0.000060             unlet s:current_errors['file'][bufnr]
    2              0.000001         endif
    2              0.000005         unlet s:need_errors_cleaning['file'][bufnr]
    2   0.000120   0.000009         call neomake#utils#DebugMessage('File-level errors cleaned in buffer '.bufnr)
    2              0.000001     endif
    4   0.049682   0.000018     call neomake#signs#CleanOldSigns(bufnr, 'file')

FUNCTION  neoinclude#file_include#get_complete_position()
Called 22 times
Total time:   0.003541
 Self time:   0.001682

count  total (s)   self (s)
   22   0.000356   0.000220   call neoinclude#initialize()
                            
   22   0.000475   0.000106   let filetype = neoinclude#util#get_context_filetype()
   22              0.000056   if filetype ==# 'java' || filetype ==# 'haskell'
                                " Cannot complete include path.
                                " You should use omnifunc plugins..
                                return -1
                              endif
                            
                              " Not Filename pattern.
   22   0.000916   0.000096   let pattern = neoinclude#get_pattern('%', filetype)
   22              0.000558   if (pattern == '' || a:input !~ pattern) && a:input =~ '\*$\|\.\.\+$\|/c\%[ygdrive/]$'
                                " Skip filename completion.
                                return -1
                              endif
                            
                              " Check include pattern.
   22   0.000630   0.000096   let pattern = neoinclude#get_pattern('%', filetype)
   22              0.000122   if pattern =~ '\w$'
   22              0.000049     let pattern .= '\m\s\+'
   22              0.000014   endif
   22              0.000143   if pattern == '' || a:input !~ pattern
   22              0.000021     return -1
                              endif
                            
                              let match_end = matchend(a:input, pattern)
                              let complete_str = matchstr(a:input[match_end :], '\f\+')
                            
                              let complete_pos = len(a:input) - len(complete_str)
                            
                              let delimiter = neoinclude#get_delimiters(filetype)
                              if delimiter != '' && strridx(complete_str, delimiter) >= 0
                                let complete_pos += strridx(complete_str, delimiter) + 1
                              endif
                            
                              return complete_pos

FUNCTION  neosnippet#handlers#_restore_unnamed_register()
Called 59 times
Total time:   0.001085
 Self time:   0.000620

count  total (s)   self (s)
   59   0.000701   0.000236   let neosnippet = neosnippet#variables#current_neosnippet()
                            
   59              0.000147   if neosnippet.unnamed_register != '' && @" !=# neosnippet.unnamed_register
                                let @" = neosnippet.unnamed_register
                                let neosnippet.unnamed_register = ''
                              endif

FUNCTION  neomake#utils#hook()
Called 6 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    6              0.000023     if exists('#User#'.a:event)
                                    let g:neomake_hook_context = a:context
                                    call neomake#utils#DebugMessage('Calling User autocmd '.a:event .' with context: '.string(a:context))
                                    if v:version >= 704 || (v:version == 703 && has('patch442'))
                                        exec 'doautocmd <nomodeline> User ' . a:event
                                    else
                                        exec 'doautocmd User ' . a:event
                                    endif
                                    unlet g:neomake_hook_context
                                endif

FUNCTION  neomake#signs#CleanOldSigns()
Called 6 times
Total time:   0.049682
 Self time:   0.049209

count  total (s)   self (s)
    6              0.000014     if !has('signs')
                                    return
                                endif
                            
    6              0.000022     if !has_key(s:last_placed_signs[a:type], a:bufnr)
    4              0.000003         return
                                endif
    2   0.000282   0.000013     call neomake#utils#DebugObject('Cleaning old signs in buffer '.a:bufnr.': ', s:last_placed_signs[a:type])
    6              0.000015     for ln in keys(s:last_placed_signs[a:type][a:bufnr])
    4              0.000021         let cmd = 'sign unplace '.s:last_placed_signs[a:type][a:bufnr][ln].' buffer='.a:bufnr
    4   0.000220   0.000017         call neomake#utils#DebugMessage('Unplacing sign: '.cmd)
    4              0.049036         exe cmd
    4              0.000011     endfor
    2              0.000014     unlet s:last_placed_signs[a:type][a:bufnr]

FUNCTION  neosnippet#variables#expand_stack()
Called 77 times
Total time:   0.000585
 Self time:   0.000585

count  total (s)   self (s)
   77              0.000238   if !exists('s:expand_stack')
                                let s:expand_stack = []
                              endif
                            
   77              0.000107   return s:expand_stack

FUNCTION  <SNR>60_is_skip()
Called 22 times
Total time:   0.003668
 Self time:   0.001326

count  total (s)   self (s)
   22   0.002306   0.000207   if s:is_skip_textwidth(deoplete#util#get_input(a:event))
                                return 1
                              endif
                            
   22   0.000435   0.000191   let disable_auto_complete = deoplete#util#get_simple_buffer_config(   'b:deoplete_disable_auto_complete',   'g:deoplete#disable_auto_complete')
                            
   22              0.000255   if &paste || mode() !=# 'i' || (a:event !=# 'Manual' && disable_auto_complete) || (&l:completefunc != '' && &l:buftype =~# 'nofile') || (a:event ==# 'InsertEnter'     && has_key(g:deoplete#_context, 'position'))
                                return 1
                              endif
                            
   22              0.000187   if !get(g:deoplete#_context, 'refresh', 0) && a:context.position ==# get(g:deoplete#_context, 'position', [])
                                let word = get(v:completed_item, 'word', '')
                                let delimiters = filter(copy(g:deoplete#delimiters),         'strridx(word, v:val) == (len(word) - len(v:val))')
                                if word == '' || empty(delimiters)
                                  return 1
                                endif
                              endif
                            
   22              0.000025   return 0

FUNCTION  <SNR>85_check_buffer()
Called 6 times
Total time:   0.004726
 Self time:   0.004579

count  total (s)   self (s)
    6              0.000042   let bufnr = (a:bufnr == '') ? bufnr('%') : a:bufnr
    6              0.000270   let filename = fnamemodify(bufname(bufnr), ':p')
                            
    6              0.000039   if !has_key(s:include_info, bufnr)
                                " Initialize.
                                let s:include_info[bufnr] = { 'include_files' : [], 'lines' : [], 'async_files' : {}, }
                              endif
                            
    6              0.000030   let include_info = s:include_info[bufnr]
                            
    6              0.000212   if a:is_force || include_info.lines !=# getbufline(bufnr, 1, 100)
                                let include_info.lines = getbufline(bufnr, 1, 100)
                            
                                " Check include files contained bufname.
                                let include_files = s:get_buffer_include_files(bufnr)
                            
                                " Check include files from function.
                                let filetype = getbufvar(a:bufnr, '&filetype')
                                let function = neoinclude#get_function(filetype)
                                if function != '' && getbufvar(bufnr, '&buftype') !~ 'nofile'
                                  let path = neoinclude#get_path(a:bufnr, filetype)
                                  let include_files += call(function, [getbufline(bufnr, 1, (a:is_force ? '$' : 1000)), path])
                                endif
                            
                                if getbufvar(bufnr, '&buftype') !~ 'nofile' && filereadable(filename)
                                  call add(include_files, filename)
                                endif
                                let include_info.include_files = neoinclude#util#uniq(include_files)
                              endif
                            
    6              0.000029   let filetype = getbufvar(bufnr, '&filetype')
    6              0.000011   if filetype == ''
                                let filetype = 'nothing'
                              endif
                            
    6   0.000212   0.000065   let ctags = neoinclude#util#get_buffer_config(filetype, 'b:neoinclude_ctags_commands', g:neoinclude#ctags_commands, g:neoinclude#_ctags_commands, '')
                            
    6              0.000135   if g:neoinclude#max_processes <= 0 || !executable(ctags)
                                return
                              endif
                            
  228              0.000283   for filename in include_info.include_files
  222              0.000850     if (a:is_force || !has_key(include_info.async_files, filename)) && !has_key(s:include_cache, filename)
                                  if !a:is_force && has_key(s:async_include_cache, filename) && len(s:async_include_cache[filename])            >= g:neoinclude#max_processes
                                    break
                                  endif
                            
                                  let s:async_include_cache[filename] = s:initialize_include(filename, filetype, ctags, a:is_force)
                                  let include_info.async_files[filename] = 1
                                endif
  222              0.000157   endfor

FUNCTION  neomake#utils#GetSetting()
Called 12 times
Total time:   0.000501
 Self time:   0.000501

count  total (s)   self (s)
   12              0.000021   if has_key(a:maker, 'name')
   12              0.000016     if len(a:fts)
   24              0.000023       for ft in a:fts
                                    " Look through the neomake setting override vars for a filetype maker,
                                    " like neomake_scss_sasslint_exe (should be a string), and 
                                    " neomake_scss_sasslint_args (should be a list)
   12              0.000039         let config_var = 'neomake_'.ft.'_'.a:maker.name.'_'.a:key
   12              0.000043         if has_key(g:, config_var) || !empty(getbufvar(a:bufnr, config_var))
                                      break
                                    endif
   12              0.000009       endfor
   12              0.000007     else
                                  " Following this, we're checking the neomake overrides for global makers
                                  let config_var = 'neomake_'.a:maker.name.'_'.a:key
                                endif
                            
   12              0.000025     if !empty(getbufvar(a:bufnr, config_var))
                                  return copy(getbufvar(a:bufnr, config_var))
                                elseif has_key(g:, config_var)
                                  return copy(get(g:, config_var))
                                endif
   12              0.000007   endif
   12              0.000019   if has_key(a:maker, a:key)
    6              0.000009     return a:maker[a:key]
                              endif
                              " Look for 'neomake_'.key in the buffer and global namespace.
    6              0.000015   let bufvar = getbufvar(a:bufnr, 'neomake_'.a:key)
    6              0.000007   if !empty(bufvar)
                                  return bufvar
                              endif
    6              0.000014   let var = get(g:, 'neomake_'.a:key)
    6              0.000007   if !empty(var)
                                  return var
                              endif
    6              0.000006   return a:default

FUNCTION  neosnippet#handlers#_all_clear_markers()
Called 2 times
Total time:   0.000170
 Self time:   0.000133

count  total (s)   self (s)
    2              0.000016   if !&l:modifiable
                                return
                              endif
                            
    2              0.000019   let pos = getpos('.')
                            
    2              0.000004   try
    2   0.000064   0.000027     while !empty(neosnippet#variables#expand_stack())
                                  call neosnippet#view#_clear_markers( neosnippet#variables#expand_stack()[-1])
                                  stopinsert
                                endwhile
    2              0.000004   finally
    2              0.000013     call setpos('.', pos)
    2              0.000004   endtry

FUNCTION  neoinclude#include#get_tag_files()
Called 2 times
Total time:   0.003417
 Self time:   0.000895

count  total (s)   self (s)
    2   0.000056   0.000031   call neoinclude#initialize()
                            
    2   0.001332   0.000018   call s:check_buffer('', 0)
                            
    2              0.000008   let bufnr = get(a:000, 0, bufnr('%'))
    2   0.001204   0.000021   let include_files = neoinclude#include#get_include_files(bufnr)
    2              0.000811   return filter(map(filter(map(include_files, 'get(s:async_include_cache, v:val, {})'), '!empty(v:val)'), 'v:val.cachename'), 'filereadable(v:val)')

FUNCTION  neomake#signs#PlaceSign()
Called 4 times
Total time:   0.040316
 Self time:   0.040096

count  total (s)   self (s)
    4              0.000012     if !has('signs')
                                    return
                                endif
                            
    4              0.000009     if a:entry.type ==? 'W'
    4              0.000007         let sign_type = 'neomake_warn'
    4              0.000005     elseif a:entry.type ==? 'I'
                                    let sign_type = 'neomake_info'
                                elseif a:entry.type ==? 'M'
                                    let sign_type = 'neomake_msg'
                                else
                                    let sign_type = 'neomake_err'
                                endif
                            
    4              0.000023     let s:placed_signs[a:type][a:entry.bufnr] = get(s:placed_signs[a:type], a:entry.bufnr, {})
    4              0.000012     if !has_key(s:placed_signs[a:type][a:entry.bufnr], a:entry.lnum)
    4              0.000009         let default = a:type ==# 'file' ? 5000 : 7000
    4              0.000013         let sign_id = get(s:neomake_sign_id[a:type], a:entry.bufnr, default)
    4              0.000013         let s:neomake_sign_id[a:type][a:entry.bufnr] = sign_id + 1
    4              0.000020         let cmd = 'sign place '.sign_id.' line='.a:entry.lnum. ' name='.sign_type. ' buffer='.a:entry.bufnr
    4              0.000014         let s:placed_signs[a:type][a:entry.bufnr][a:entry.lnum] = sign_id
    4              0.000004     elseif sign_type ==# 'neomake_err'
                                    " Upgrade this sign to an error
                                    let sign_id = s:placed_signs[a:type][a:entry.bufnr][a:entry.lnum]
                                    let cmd =  'sign place '.sign_id.' name='.sign_type.' buffer='.a:entry.bufnr
                                else
                                    let cmd = ''
                                endif
                            
    4              0.000006     if len(cmd)
    4   0.000237   0.000017         call neomake#utils#DebugMessage('Placing sign: '.cmd)
    4              0.039863         exe cmd
    4              0.000009     endif

FUNCTION  neosnippet#commands#_make_cache()
Called 4 times
Total time:   0.000092
 Self time:   0.000059

count  total (s)   self (s)
    4   0.000025   0.000010   call neosnippet#init#check()
                            
    4              0.000009   let filetype = a:filetype == '' ? &filetype : a:filetype
    4              0.000004   if filetype ==# ''
                                let filetype = 'nothing'
                              endif
                            
    4   0.000033   0.000014   let snippets = neosnippet#variables#snippets()
    4              0.000007   if has_key(snippets, filetype)
    4              0.000002     return
                              endif
                            
                              let snippets[filetype] = {}
                            
                              let path = join(neosnippet#helpers#get_snippets_directory(), ',')
                              let cache_dir = neosnippet#variables#data_dir()
                            
                              for filename in s:get_snippets_files(path, filetype)
                                " Clear cache file
                                call s:Cache.deletefile(cache_dir, filename)
                                let snippets[filetype] = extend(snippets[filetype], neosnippet#parser#_parse_snippets(filename))
                              endfor
                            
                              if g:neosnippet#enable_snipmate_compatibility
                                " Load file snippets
                                for filename in s:get_snippet_files(path, filetype)
                                  let trigger = fnamemodify(filename, ':t:r')
                                  let snippets[filetype][trigger] = neosnippet#parser#_parse_snippet(filename, trigger)
                                endfor
                              endif

FUNCTION  neomake#utils#LogMessage()
Called 232 times
Total time:   0.011673
 Self time:   0.011673

count  total (s)   self (s)
  232              0.000599     let verbose = get(g:, 'neomake_verbose', 1)
  232              0.000434     let logfile = get(g:, 'neomake_logfile')
                            
  232              0.000816     if exists(':Log') != 2 && verbose < a:level && logfile is# ''
                                    return
                                endif
                            
  232              0.000176     if a:0
  220              0.000263         let jobinfo = a:1
  220              0.000328         if has_key(jobinfo, 'id')
  216              0.000862             let msg = printf('[%d.%d] %s', jobinfo.make_id, jobinfo.id, a:msg)
  216              0.000127         else
    4              0.000026             let msg = printf('[%d] %s', jobinfo.make_id, a:msg)
    4              0.000003         endif
  220              0.000105     else
   12              0.000013         let jobinfo = {}
   12              0.000014         let msg = a:msg
   12              0.000006     endif
                            
  232              0.000388     if exists('*vader#log')
                                    " Log is defined during Vader tests.
                                    let test_msg = '['.s:level_to_name[a:level].'] ['.s:timestr().']: '.msg
                                    call vader#log(test_msg)
                                    " Only keep jobinfo entries that are relevant for / used in the message.
                                    let g:neomake_test_messages += [[a:level, a:msg, filter(copy(jobinfo), "index(['id', 'make_id'], v:key) != -1")]]
                                endif
                            
  232              0.000253     if verbose >= a:level
                                    redraw
                                    if a:level ==# 0
                                        echohl ErrorMsg
                                    endif
                                    if verbose > 2
                                        echom 'Neomake ['.s:timestr().']: '.msg
                                    else
                                        echom 'Neomake: '.msg
                                    endif
                                    if a:level ==# 0
                                        echohl None
                                    endif
                                endif
  232              0.000585     if type(logfile) ==# type('') && len(logfile)
                                    let date = strftime('%Y-%m-%dT%H:%M:%S%z')
                                    call writefile(['['.date.' @'.s:timestr().', '.s:level_to_name[a:level].'] '.msg], logfile, 'a')
                                endif

FUNCTION  neomake#has_async_support()
Called 6 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    6              0.000023     return has('nvim') || has('channel') && has('job') && has('patch-8.0.0027')

FUNCTION  delimitMate#WithinEmptyPair()
Called 10 times
Total time:   0.001243
 Self time:   0.000275

count  total (s)   self (s)
                              " if cursor is at column 1 return 0
   10              0.000029   if col('.') == 1
                                return 0
                              endif
                              " get char before the cursor.
   10   0.000521   0.000071   let char1 = s:get_char(-1)
                              " get char under the cursor.
   10   0.000281   0.000055   let char2 = s:get_char(0)
   10   0.000357   0.000064   return delimitMate#IsEmptyPair( char1.char2 )

FUNCTION  <SNR>18_is_empty_matchpair()
Called 11 times
Total time:   0.000837
 Self time:   0.000195

count  total (s)   self (s)
                              " get char before the cursor.
   11   0.000434   0.000056   let open = s:get_char(-1)
   11   0.000297   0.000078   let idx = index(s:get('left_delims'), open)
   11              0.000017   if idx == -1
   10              0.000011     return 0
                              endif
    1   0.000028   0.000008   let close = get(s:get('right_delims'), idx, '')
    1   0.000030   0.000006   return close ==# s:get_char(0)

FUNCTION  neomake#utils#DebugMessage()
Called 230 times
Total time:   0.012920
 Self time:   0.001363

count  total (s)   self (s)
  230   0.012832   0.001275     call call('neomake#utils#LogMessage', [3] + a:000)

FUNCTION  neomake#signs#ResetFile()
Called 2 times
Total time:   0.000085
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000014     let s:sign_queue.file[a:bufnr] = {}
    2   0.000028   0.000010     call neomake#signs#CleanOldSigns(a:bufnr, 'file')
    2   0.000031   0.000008     call neomake#signs#Reset(a:bufnr, 'file')
    2              0.000005     if has_key(s:neomake_sign_id.file, a:bufnr)
    2              0.000004         unlet s:neomake_sign_id.file[a:bufnr]
    2              0.000001     endif

FUNCTION  neosnippet#variables#snippets()
Called 8 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    8              0.000013   if !exists('s:snippets')
                                let s:snippets= {}
                              endif
                            
    8              0.000007   return s:snippets

FUNCTION  <SNR>18_is_jump()
Called 2 times
Total time:   0.000211
 Self time:   0.000055

count  total (s)   self (s)
                              " Returns 1 if the next character is a closing delimiter.
    2   0.000081   0.000013   let char = s:get_char(0)
    2   0.000109   0.000022   let list = s:get('right_delims') + s:get('quotes_list')
                            
                              " Closing delimiter on the right.
    2              0.000012   if (!a:0 && index(list, char) > -1) || (a:0 && char == a:1)
    2              0.000002     return 1
                              endif
                            
                              " Closing delimiter with space expansion.
                              let nchar = s:get_char(1)
                              if !a:0 && s:get('expand_space') && char == " "
                                if index(list, nchar) > -1
                                  return 2
                                endif
                              elseif a:0 && s:get('expand_space') && nchar == a:1 && char == ' '
                                return 3
                              endif
                            
                              if !s:get('jump_expansion')
                                return 0
                              endif
                            
                              " Closing delimiter with CR expansion.
                              let uchar = matchstr(getline(line('.') + 1), '^\s*\zs\S')
                              if !a:0 && s:get('expand_cr') && char == ""
                                if index(list, uchar) > -1
                                  return 4
                                endif
                              elseif a:0 && s:get('expand_cr') && uchar == a:1
                                return 5
                              endif
                              return 0

FUNCTION  deoplete#util#convert2list()
Called 70 times
Total time:   0.000569
 Self time:   0.000569

count  total (s)   self (s)
   70              0.000511   return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  deoplete#util#vimoption2python()
Called 24 times
Total time:   0.008750
 Self time:   0.000318

count  total (s)   self (s)
   24   0.008734   0.000302   return '[a-zA-Z' . s:vimoption2python(a:option) . ']'

FUNCTION  neomake#utils#Stringify()
Called 8 times
Total time:   0.000315
 Self time:   0.000151

count  total (s)   self (s)
    8              0.000016     if type(a:obj) == type([])
                                    let ls = map(copy(a:obj), 'neomake#utils#Stringify(v:val)')
                                    return '['.join(ls, ', ').']'
                                elseif type(a:obj) == type({})
    4              0.000004         let ls = []
   10              0.000013         for key in keys(a:obj)
    6              0.000022             call add(ls, key.': '.neomake#utils#Stringify(a:obj[key]))
    6              0.000004         endfor
    4              0.000009         return '{'.join(ls, ', ').'}'
                                else
    4              0.000005         return ''.a:obj
                                endif

FUNCTION  <SNR>45_AddExprCallback()
Called 2 times
Total time:   0.065998
 Self time:   0.008355

count  total (s)   self (s)
    2              0.000004     let maker = a:jobinfo.maker
    2              0.000005     let file_mode = get(maker, 'file_mode')
    2              0.000005     let place_signs = get(g:, 'neomake_place_signs', 1)
    2              0.000168     let list = file_mode ? getloclist(0) : getqflist()
    2              0.000003     let list_modified = 0
    2              0.000002     let counts_changed = 0
    2              0.000003     let index = a:prev_index
    2              0.000003     let maker_type = file_mode ? 'file' : 'project'
    2              0.000002     let cleaned_signs = 0
    2              0.000002     let ignored_signs = 0
                            
  178              0.000251     while index < len(list)
  176              0.000361         let entry = list[index]
  176              0.000441         let entry.maker_name = has_key(maker, 'name') ? maker.name : 'makeprg'
  176              0.000167         let index += 1
                            
  176              0.000245         if has_key(maker, 'postprocess')
                                        if list_modified
                                            call maker.postprocess(entry)
                                        else
                                            let before = copy(entry)
                                            call maker.postprocess(entry)
                                            if entry != before
                                                let list_modified = 1
                                            endif
                                        endif
                                    endif
                            
  176              0.000146         if !entry.valid
  118              0.000100             if maker.remove_invalid_entries
  118              0.000119                 let index -= 1
  118              0.000192                 call remove(list, index)
  118              0.000123                 let list_modified = 1
  118              0.000364                 let entry_copy = copy(entry)
  118   0.006987   0.001023                 call neomake#utils#DebugMessage(printf( 'Removing invalid entry: %s (%s)', remove(entry_copy, 'text'), string(entry_copy)), a:jobinfo)
  118              0.000057             endif
  118              0.000094             continue
                                    endif
                            
   58              0.000046         if !file_mode
                                        if neomake#statusline#AddQflistCount(entry)
                                            let counts_changed = 1
                                        endif
                                    endif
                            
   58              0.000045         if !entry.bufnr
                                        continue
                                    endif
                            
   58              0.000043         if file_mode
   58   0.001159   0.000175             if neomake#statusline#AddLoclistCount(entry.bufnr, entry)
   58              0.000067                 let counts_changed = 1
   58              0.000029             endif
   58              0.000025         endif
                            
   58              0.000048         if !cleaned_signs
    2              0.000001             if file_mode
    2   0.049880   0.000013                 call neomake#CleanOldFileSignsAndErrors(entry.bufnr)
    2              0.000002             else
                                            call neomake#CleanOldProjectSignsAndErrors()
                                        endif
    2              0.000006             let cleaned_signs = 1
    2              0.000001         endif
                            
                                    " Track all errors by buffer and line
   58              0.000256         let s:current_errors[maker_type][entry.bufnr] = get(s:current_errors[maker_type], entry.bufnr, {})
   58              0.000310         let s:current_errors[maker_type][entry.bufnr][entry.lnum] = get( s:current_errors[maker_type][entry.bufnr], entry.lnum, [])
   58              0.000198         call add(s:current_errors[maker_type][entry.bufnr][entry.lnum], entry)
                            
   58              0.000050         if place_signs
   58              0.000052             if entry.lnum is 0
                                            let ignored_signs += 1
                                        else
   58   0.001012   0.000184                 call neomake#signs#RegisterSign(entry, maker_type)
   58              0.000028             endif
   58              0.000025         endif
   58              0.000035     endwhile
                            
    2              0.000002     if list_modified
    2              0.000002         if file_mode
    2              0.000045             call setloclist(0, list, 'r')
    2              0.000001         else
                                        call setqflist(list, 'r')
                                    endif
    2              0.000001     endif
    2              0.000002     if ignored_signs
                                    call neomake#utils#DebugMessage(printf( 'Could not place signs for %d entries without line number.', ignored_signs))
                                endif
    2              0.000002     return counts_changed

FUNCTION  neomake#signs#Reset()
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000005     if has_key(s:placed_signs[a:type], a:bufnr)
    2              0.000010         let s:last_placed_signs[a:type][a:bufnr] = s:placed_signs[a:type][a:bufnr]
    2              0.000005         unlet s:placed_signs[a:type][a:bufnr]
    2              0.000001     endif

FUNCTION  neomake#utils#DebugObject()
Called 2 times
Total time:   0.000269
 Self time:   0.000016

count  total (s)   self (s)
    2   0.000268   0.000015     call neomake#utils#DebugMessage(a:msg.' '.neomake#utils#Stringify(a:obj))

FUNCTION  <SNR>18_is_smart_quote()
Called 1 time
Total time:   0.000154
 Self time:   0.000132

count  total (s)   self (s)
                              " TODO: Allow using a:char in the pattern.
    1   0.000028   0.000007   let tmp = s:get('smart_quotes')
    1              0.000003   if empty(tmp)
                                return 0
                              endif
    1              0.000022   let regex = matchstr(tmp, '^!\?\zs.*')
                              " Flip matched value if regex starts with !
    1              0.000007   let mod = tmp =~ '^!' ? [1, 0] : [0, 1]
    1              0.000045   let matched = search(regex, 'ncb', line('.')) > 0
    1              0.000009   let noescaped = substitute(getline('.'), '\\.', '', 'g')
    1              0.000027   let odd =  (count(split(noescaped, '\zs'), a:char) % 2)
    1              0.000005   let result = mod[matched] || odd
    1              0.000002   return result

FUNCTION  <SNR>58_vimoption2python()
Called 26 times
Total time:   0.009519
 Self time:   0.005685

count  total (s)   self (s)
   26              0.000081   let has_dash = 0
   26              0.000060   let patterns = []
  150              0.000491   for pattern in split(a:option, ',')
  124              0.000260     if pattern == ''
                                  " ,
    4              0.000008       call add(patterns, ',')
    4              0.000004     elseif pattern == '-'
    2              0.000003       let has_dash = 1
    2              0.000002     elseif pattern =~ '\d\+'
   50              0.001140       call add(patterns, substitute(pattern, '\d\+', '\=nr2char(submatch(0))', 'g'))
   50              0.000064     else
   68              0.000254       call add(patterns, pattern)
   68              0.000092     endif
  124              0.000145   endfor
                            
                              " Dash must be last.
   26              0.000048   if has_dash
    2              0.000004     call add(patterns, '-')
    2              0.000001   endif
                            
   26   0.004178   0.000343   return join(deoplete#util#uniq(patterns), '')

FUNCTION  <SNR>60_completion_check()
Called 59 times
Total time:   0.001659
 Self time:   0.001659

count  total (s)   self (s)
   59              0.000300   let delay = get(g:deoplete#_context, 'refresh', 0) ? g:deoplete#auto_refresh_delay : g:deoplete#auto_complete_delay
   59              0.000209   if has('timers') && delay > 0
   59              0.000108     if exists('s:timer')
   37              0.000124       call timer_stop(s:timer.id)
   37              0.000022     endif
                            
   59              0.000101     if a:event != 'Manual'
   59              0.000250       let s:timer = { 'event': a:event, 'changedtick': b:changedtick }
   59              0.000301       let s:timer.id = timer_start(delay, 's:completion_delayed')
   59              0.000047       return
                                endif
                              endif
                            
                              return s:completion_begin(a:event)

FUNCTION  <SNR>80_setCount()
Called 58 times
Total time:   0.000513
 Self time:   0.000513

count  total (s)   self (s)
   58              0.000123     let type = toupper(a:item.type)
   58              0.000138     if len(type) && (!a:buf || a:item.bufnr ==# a:buf)
   58              0.000174         let a:counts[type] = get(a:counts, type, 0) + 1
   58              0.000041         return 1
                                endif
                                return 0

FUNCTION  <SNR>18_get()
Called 158 times
Total time:   0.003648
 Self time:   0.003648

count  total (s)   self (s)
  158              0.000278   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
                              elseif a:0 == 1
                                let bufoptions = get(s:options, bufnr('%'), {})
                                return deepcopy(get(bufoptions, a:name, a:1))
                              else
  158              0.001392     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  neomake#utils#ExpandArgs()
Called 2 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
                                " Only expand those args that start with \ and a single %
    2              0.000103     call map(a:args, "v:val =~# '\\(^\\\\\\|^%$\\|^%[^%]\\)' ? expand(v:val) : v:val")

FUNCTION  neoinclude#include#get_include_files()
Called 2 times
Total time:   0.001183
 Self time:   0.000051

count  total (s)   self (s)
    2   0.000013   0.000006   call neoinclude#initialize()
                            
    2   0.001135   0.000009   call s:check_buffer('', 0)
                            
    2              0.000008   let bufnr = get(a:000, 0, bufnr('%'))
    2              0.000005   if has_key(s:include_info, bufnr)
    2              0.000018     return copy(s:include_info[bufnr].include_files)
                              else
                                return s:get_buffer_include_files(bufnr)
                              endif

FUNCTION  <SNR>45_gettabwinvar()
Called 10 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
                                " Wrapper around gettabwinvar that has no default (Vim in Travis).
   10              0.000041     let r = gettabwinvar(a:t, a:w, a:v)
   10              0.000011     if r is# ''
    2              0.000002         unlet r
    2              0.000002         let r = a:d
    2              0.000001     endif
   10              0.000009     return r

FUNCTION  delimitMate#ExpandReturn()
Called 1 time
Total time:   0.001118
 Self time:   0.000116

count  total (s)   self (s)
    1   0.000725   0.000010   if s:is_forbidden("")
                                return "\<CR>"
                              endif
    1   0.000098   0.000014   let escaped = s:cursor_idx() >= 2 && s:get_char(-2) == '\'
    1   0.000033   0.000010   let expand_right_matchpair = s:get('expand_cr') == 2     && index(s:get('right_delims'), s:get_char(0)) > -1
    1   0.000027   0.000008   let expand_inside_quotes = s:get('expand_inside_quotes')     && s:is_empty_quotes()     && !escaped
    1   0.000147   0.000006   let is_empty_matchpair = s:is_empty_matchpair()
    1              0.000005   if !pumvisible(  ) && (   is_empty_matchpair     || expand_right_matchpair     || expand_inside_quotes)
    1              0.000004     let val = "\<Esc>a"
    1   0.000030   0.000009     if is_empty_matchpair && s:get('insert_eol_marker') == 2 && !search(escape(s:get('eol_marker'), '[]\.*^$').'$', 'cnW', '.')
                                  let tail = getline('.')[col('.') - 1 : ]
                                  let times = len(split(tail, '\zs'))
                                  let val .= repeat(s:joinUndo() . "\<Right>", times) . s:get('eol_marker') . repeat(s:joinUndo() . "\<Left>", times + 1)
                                endif
    1              0.000004     let val .= "\<CR>"
    1              0.000005     if &smartindent && !&cindent && !&indentexpr && s:get_char(0) == '}'
                                  " indentation is controlled by 'smartindent', and the first character on
                                  " the new line is '}'. If this were typed manually it would reindent to
                                  " match the current line. Let's reproduce that behavior.
                                  let shifts = indent('.') / &sw
                                  let spaces = indent('.') - (shifts * &sw)
                                  let val .= "^\<C-D>".repeat("\<C-T>", shifts).repeat(' ', spaces)
                                endif
                                " Expand:
                                " XXX zv prevents breaking expansion with syntax folding enabled by
                                " InsertLeave.
    1              0.000003     let val .= "\<Esc>zvO"
    1              0.000002     return val
                              else
                                return "\<CR>"
                              endif

FUNCTION  neomake#CursorMoved()
Called 17 times
Total time:   0.012548
 Self time:   0.000979

count  total (s)   self (s)
   17              0.000245     let l:line = line('.')
   17              0.000208     if s:last_cursormoved[0] != l:line || s:last_cursormoved[1] != bufnr('%')
   14              0.000147         let s:last_cursormoved = [l:line, bufnr('%')]
   14   0.010673   0.000149         call neomake#signs#PlaceVisibleSigns()
   14   0.001173   0.000127         call neomake#EchoCurrentError()
   14              0.000015     endif

FUNCTION  neomake#makers#ft#c#clang()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000014     return { 'args': ['-fsyntax-only', '-Wall', '-Wextra'], 'errorformat': '%-G%f:%s:,' . '%f:%l:%c: %trror: %m,' . '%f:%l:%c: %tarning: %m,' . '%f:%l:%c: %m,'. '%f:%l: %trror: %m,'. '%f:%l: %tarning: %m,'. '%f:%l: %m', }

FUNCTION  <SNR>45_getwinvar()
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
                                " Wrapper around getwinvar that has no default (Vim in Travis).
    2              0.000004     let r = getwinvar(a:w, a:v)
    2              0.000002     if r is# ''
                                    unlet r
                                    let r = a:d
                                endif
    2              0.000001     return r

FUNCTION  neomake#EchoCurrentError()
Called 16 times
Total time:   0.001125
 Self time:   0.001125

count  total (s)   self (s)
   16              0.000084     if !get(g:, 'neomake_echo_current_error', 1)
                                    return
                                endif
                            
   16              0.000082     if !empty(get(s:, 'neomake_last_echoed_error', {}))
                                    unlet s:neomake_last_echoed_error
                                    echon ''
                                endif
                            
   16              0.000053     let buf = bufnr('%')
   16              0.000047     let ln = line('.')
   16              0.000037     let ln_errors = []
                            
   48              0.000104     for maker_type in ['file', 'project']
   32              0.000180         let buf_errors = get(s:current_errors[maker_type], buf, {})
   32              0.000141         let ln_errors += get(buf_errors, ln, [])
   32              0.000030     endfor
                            
   16              0.000040     if empty(ln_errors)
   16              0.000021         return
                                endif
                            
                                let s:neomake_last_echoed_error = ln_errors[0]
                                for error in ln_errors
                                    if error.type ==# 'E'
                                        let s:neomake_last_echoed_error = error
                                        break
                                    endif
                                endfor
                                let message = s:neomake_last_echoed_error.maker_name.': '.s:neomake_last_echoed_error.text
                                call neomake#utils#WideMessage(message)

FUNCTION  <SNR>18_joinUndo()
Called 5 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    5              0.000046   if v:version < 704 || ( v:version == 704 && !has('patch849') )
                                return ''
                              endif
    5              0.000013   return "\<C-G>U"

FUNCTION  neomake#signs#PlaceVisibleSigns()
Called 16 times
Total time:   0.051598
 Self time:   0.011282

count  total (s)   self (s)
   48              0.000139     for type in ['file', 'project']
   32              0.000148         let buf = bufnr('%')
   32              0.000188         if !has_key(s:sign_queue[type], buf)
   16              0.000029             continue
                                    endif
   16              0.000079         let topline = line('w0')
   16              0.000043         let botline = line('w$')
  800              0.001095         for ln in range(topline, botline)
  784              0.003520             if has_key(s:sign_queue[type][buf], ln)
    4   0.040354   0.000038                 call neomake#signs#PlaceSign(s:sign_queue[type][buf][ln], type)
    4              0.000024                 unlet s:sign_queue[type][buf][ln]
    4              0.000002             endif
  784              0.000754         endfor
   16              0.000075         if empty(s:sign_queue[type][buf])
                                        unlet s:sign_queue[type][buf]
                                    endif
   16              0.000015     endfor

FUNCTION  <SNR>60_on_insert_leave()
Called 3 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    3              0.000031   if exists('g:deoplete#_saved_completeopt')
    2              0.000027     let &completeopt = g:deoplete#_saved_completeopt
    2              0.000008     unlet g:deoplete#_saved_completeopt
    2              0.000004   endif
    3              0.000017   let g:deoplete#_context = {}

FUNCTION  neosnippet#variables#current_neosnippet()
Called 61 times
Total time:   0.000488
 Self time:   0.000488

count  total (s)   self (s)
   61              0.000153   if !exists('b:neosnippet')
                                let b:neosnippet = { 'snippets' : {}, 'selected_text' : '', 'target' : '', 'trigger' : 0, 'optional_tabstop' : 0, 'unnamed_register' : '',}
                              endif
                            
   61              0.000071   return b:neosnippet

FUNCTION  neomake#GetMaker()
Called 2 times
Total time:   0.000931
 Self time:   0.000369

count  total (s)   self (s)
    2              0.000002     if a:0
    2              0.000003         let real_ft = a:1
    2   0.000034   0.000007         let fts = neomake#utils#GetSortedFiletypes(real_ft)
    2              0.000001     else
                                    let fts = []
                                endif
    2              0.000006     if type(a:name_or_maker) == type({})
                                    let maker = a:name_or_maker
                                elseif a:name_or_maker ==# 'makeprg'
                                    let maker = neomake#utils#MakerFromCommand(&makeprg)
                                elseif a:name_or_maker !~# '\v^\w+$'
                                    call neomake#utils#ErrorMessage('Invalid maker name: '.a:name_or_maker)
                                    return {}
                                else
    2              0.000003         if len(fts)
    4              0.000005             for ft in fts
    2              0.000008                 let m = get(g:, 'neomake_'.ft.'_'.a:name_or_maker.'_maker')
    2              0.000004                 if type(m) == type({})
                                                let maker = m
                                                break
                                            endif
    2              0.000002                 unlet m
    2              0.000001             endfor
    2              0.000003         elseif exists('g:neomake_'.a:name_or_maker.'_maker')
                                        let maker = get(g:, 'neomake_'.a:name_or_maker.'_maker')
                                    endif
    2              0.000004         if !exists('maker')
    2              0.000003             if len(fts)
    2              0.000003                 for ft in fts
    2              0.000002                     try
    2   0.000051   0.000016                         let maker = eval('neomake#makers#ft#'.ft.'#'.a:name_or_maker.'()')
    2              0.000002                         break
                                                catch /^Vim\%((\a\+)\)\=:E117/
                                                endtry
                                            endfor
    2              0.000001             else
                                            try
                                                let maker = eval('neomake#makers#'.a:name_or_maker.'#'.a:name_or_maker.'()')
                                            catch /^Vim\%((\a\+)\)\=:E117/
                                            endtry
                                        endif
    2              0.000001         endif
    2              0.000004         if !exists('maker')
                                        call neomake#utils#ErrorMessage('Maker not found: '.a:name_or_maker)
                                        return {}
                                    endif
    2              0.000001     endif
    2              0.000008     let maker = deepcopy(maker)
    2              0.000004     if !has_key(maker, 'name')
    2              0.000005         if type(a:name_or_maker) == type('')
    2              0.000004             let maker.name = a:name_or_maker
    2              0.000001         else
                                        let maker.name = 'unnamed_maker'
                                    endif
    2              0.000001     endif
    2              0.000011     let defaults = { 'exe': maker.name, 'args': [], 'errorformat': &errorformat, 'buffer_output': 1, 'remove_invalid_entries': 1, }
    2              0.000004     let bufnr = bufnr('%')
   12              0.000029     for [key, default] in items(defaults)
   10   0.000465   0.000055         let maker[key] = neomake#utils#GetSetting(key, maker, default, fts, bufnr)
   10              0.000009         unlet! default  " workaround for old Vim (7.3.429)
   10              0.000006     endfor
    2              0.000004     let s:UNSET = {}
    4              0.000005     for key in ['append_file']
    2   0.000100   0.000009         let value = neomake#utils#GetSetting(key, maker, s:UNSET, fts, bufnr)
    2              0.000003         if value isnot s:UNSET
                                        let maker[key] = value
                                    endif
    2              0.000002         unlet! value  " workaround for old Vim (7.3.429)
    2              0.000001     endfor
    2              0.000004     if exists('real_ft')
    2              0.000004         let maker.ft = real_ft
    2              0.000001     endif
    2              0.000002     return maker

FUNCTION  neomake#statusline#AddLoclistCount()
Called 58 times
Total time:   0.000984
 Self time:   0.000471

count  total (s)   self (s)
   58              0.000203     let s:loclist_counts[a:buf] = get(s:loclist_counts, a:buf, {})
   58   0.000756   0.000243     return s:setCount(s:loclist_counts[a:buf], a:item, a:buf)

FUNCTION  deoplete#util#get_next_input()
Called 24 times
Total time:   0.001569
 Self time:   0.000203

count  total (s)   self (s)
   24   0.001557   0.000191   return getline('.')[len(deoplete#util#get_input(a:event)) :]

FUNCTION  <SNR>60_completion_begin()
Called 22 times
Total time:   0.040043
 Self time:   0.003763

count  total (s)   self (s)
   22   0.031753   0.000303   let context = deoplete#init#_context(a:event, [])
   22   0.003819   0.000151   if s:is_skip(a:event, context)
                                return
                              endif
                            
                              " Save the previous position
   22              0.000093   let g:deoplete#_context.position = context.position
                            
   22              0.000055   let g:deoplete#_context.refresh = 0
                            
                              " Call omni completion
   44              0.000098   for filetype in context.filetypes
   44   0.001227   0.000300     for pattern in deoplete#util#convert2list( deoplete#util#get_buffer_config(filetype, 'b:deoplete_omni_patterns', 'g:deoplete#omni_patterns', 'g:deoplete#_omni_patterns'))
   22              0.000087       if pattern != '' && &l:omnifunc != '' && context.input =~# '\%('.pattern.'\)$'
                                    call deoplete#mapping#_set_completeopt()
                                    call feedkeys("\<C-x>\<C-o>", 'n')
                                    return
                                  endif
   22              0.000026     endfor
   22              0.000021   endfor
                            
   22   0.000358   0.000122   call deoplete#mapping#_set_completeopt()
   22              0.001643   call rpcnotify(g:deoplete#_channel_id, 'deoplete_auto_completion_begin', context)

FUNCTION  neomake#signs#DefineSigns()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000008     if !has('signs')
                                    return
                                endif
                            
    2              0.000003     if !s:signs_defined
                                    let s:signs_defined = 1
                                    call neomake#signs#RedefineErrorSign()
                                    call neomake#signs#RedefineWarningSign()
                                    call neomake#signs#RedefineInfoSign()
                                    call neomake#signs#RedefineMessageSign()
                                endif

FUNCTION  neosnippet#init#check()
Called 6 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    6              0.000016   if !exists('s:is_initialized')
                                call neosnippet#init#_initialize()
                              endif

FUNCTION  neomake#utils#GetSortedFiletypes()
Called 4 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    4              0.000022     function! CompareFiletypes(ft1, ft2) abort
                                    if neomake#utils#GetSupersetOf(a:ft1) ==# a:ft2
                                        return -1
                                    elseif neomake#utils#GetSupersetOf(a:ft2) ==# a:ft1
                                        return 1
                                    else
                                        return 0
                                    endif
                                endfunction
                            
    4              0.000051     return sort(split(a:ft, '\.'), function('CompareFiletypes'))

FUNCTION  neomake#ProcessCurrentWindow()
Called 4 times
Total time:   0.117876
 Self time:   0.000177

count  total (s)   self (s)
    4              0.000048     let outputs = get(w:, 'neomake_jobs_output', [])
    4              0.000015     if len(outputs)
    2              0.000003         unlet w:neomake_jobs_output
    4              0.000005         for output in outputs
    2   0.076650   0.000024             call s:ProcessJobOutput(output.jobinfo, output.lines, output.source)
    2              0.000001         endfor
    2   0.041081   0.000007         call neomake#signs#PlaceVisibleSigns()
    2              0.000001     endif

FUNCTION  neomake#statusline#ResetCountsForBuf()
Called 2 times
Total time:   0.000071
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000005     let bufnr = a:0 ? a:1 : bufnr('%')
    2              0.000007     let r = (get(s:loclist_counts, bufnr, {}) != {})
    2              0.000006     let s:loclist_counts[bufnr] = {}
    2              0.000002     if r
    2   0.000045   0.000013         call neomake#utils#hook('NeomakeCountsChanged', { 'file_mode': 1, 'bufnr': bufnr})
    2              0.000001     endif
    2              0.000002     return r

FUNCTION  delimitMate#JumpAny()
Called 2 times
Total time:   0.001753
 Self time:   0.000105

count  total (s)   self (s)
    2   0.001379   0.000020   if s:is_forbidden('')
                                return ''
                              endif
    2   0.000227   0.000016   if !s:is_jump()
                                return ''
                              endif
                              " Let's get the character on the right.
    2   0.000060   0.000013   let char = s:get_char(0)
    2              0.000006   if char == " "
                                " Space expansion.
                                return s:joinUndo() . "\<Right>" . s:joinUndo() . "\<Right>"
                              elseif char == ""
                                " CR expansion.
                                return "\<CR>" . getline(line('.') + 1)[0] . "\<Del>\<Del>"
                              else
    2   0.000043   0.000012     return s:joinUndo() . "\<Right>"
                              endif

FUNCTION  <SNR>18_cursor_idx()
Called 11 times
Total time:   0.000366
 Self time:   0.000366

count  total (s)   self (s)
   11              0.000338   let idx = len(split(getline('.')[: col('.') - 1], '\zs')) - 1
   11              0.000018   return idx

FUNCTION  <SNR>45_HandleLoclistQflistDisplay()
Called 4 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    4              0.000011     let open_val = get(g:, 'neomake_open_list')
    4              0.000004     if open_val
                                    let height = get(g:, 'neomake_list_height', 10)
                                    let win_val = winnr()
                                    if a:file_mode
                                        exe 'lwindow' height
                                    else
                                        exe 'cwindow' height
                                    endif
                                    if open_val == 2 && win_val != winnr()
                                        wincmd p
                                    endif
                                endif

FUNCTION  <SNR>45_GetMakerKey()
Called 6 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    6              0.000031     return a:maker.name.',ft='.a:maker.ft.',buf='.a:maker.bufnr

FUNCTION  deoplete#util#get_simple_buffer_config()
Called 22 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
   22              0.000228   return exists(a:buffer_var) ? {a:buffer_var} : {a:user_var}

FUNCTION  deoplete#util#get_buffer_config()
Called 70 times
Total time:   0.003046
 Self time:   0.003046

count  total (s)   self (s)
   70              0.000362   let default_val = get(a:000, 0, '')
                            
   70              0.000329   if exists(a:buffer_var)
                                return {a:buffer_var}
                              endif
                            
   70              0.001036   let filetype = !has_key({a:user_var}, a:filetype) && !has_key(eval(a:default_var), a:filetype) ? '_' : a:filetype
                            
   70              0.000805   return get({a:user_var}, filetype,   get(eval(a:default_var), filetype, default_val))

FUNCTION  <SNR>25_OnCommand()
Called 2 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    2              0.000030     if getcmdtype() == "/" || getcmdtype() == "?"
                                    call s:Stop()
                                    return "\<CR>:call <SNR>".s:SID()."_Start()\<CR>"
                                else
    2              0.000007         return "\<CR>"
                                endif

FUNCTION  neoinclude#initialize()
Called 26 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
   26              0.000093   if s:initialized
   26              0.000031     return
                              endif
                            
                              let g:neoinclude#ctags_commands = get(g:, 'neoinclude#ctags_commands', {})
                              let g:neoinclude#_ctags_commands = {}
                              let g:neoinclude#ctags_arguments = get(g:, 'neoinclude#ctags_arguments', {})
                              let g:neoinclude#_ctags_arguments = {}
                              let g:neoinclude#max_processes = get(g:, 'neoinclude#max_processes', 20)
                              let g:neoinclude#paths = get(g:, 'neoinclude#paths', {})
                              let g:neoinclude#_paths = {}
                              let g:neoinclude#patterns = get(g:, 'neoinclude#patterns', {})
                              let g:neoinclude#_patterns = {}
                              let g:neoinclude#exprs = get(g:, 'neoinclude#exprs', {})
                              let g:neoinclude#_exprs = {}
                              let g:neoinclude#exts = get(g:, 'neoinclude#exts', {})
                              let g:neoinclude#_exts = {}
                              let g:neoinclude#reverse_exprs = get(g:, 'neoinclude#reverse_exprs', {})
                              let g:neoinclude#_reverse_exprs = {}
                              let g:neoinclude#functions = get(g:, 'neoinclude#functions', {})
                              let g:neoinclude#_functions = {}
                              let g:neoinclude#delimiters = get(g:, 'neoinclude#delimiters', {})
                              let g:neoinclude#_delimiters = {}
                              let g:neoinclude#suffixes = get(g:, 'neoinclude#suffixes', {})
                              let g:neoinclude#_suffixes = {}
                            
                              " Initialize include pattern. "{{{
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'java,haskell', '^\s*\<import')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'c,cpp', '^\s*#\s*include')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'cs', '^\s*\<using')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'ruby', '^\s*\<\%(load\|require\|require_relative\)\>')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'r', '^\s*source(')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_patterns', 'html,xhtml,xml,markdown,mkd', '\%(src\|href\)="\ze[^"]*$')
                              "}}}
                              " Initialize include suffixes. "{{{
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_suffixes', 'haskell', '.hs')
                              "}}}
                              " Initialize include functions. "{{{
                              " call neoinclude#util#set_default_dictionary(
                              "       \ 'g:neoinclude#_functions', 'vim',
                              "       \ 'neoinclude#analyze_vim_include_files')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_functions', 'ruby', 'neoinclude#analyze_ruby_include_files')
                              "}}}
                              " Initialize filename include expr. "{{{
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_reverse_exprs', 'perl', 'substitute(v:fname, "/", "::", "g")')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_reverse_exprs', 'java,d', 'substitute(v:fname, "/", ".", "g")')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_reverse_exprs', 'ruby', 'substitute(v:fname, "\.rb$", "", "")')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_reverse_exprs', 'python', "substitute(substitute(v:fname, '\\v.*egg%(-info|-link)?$', '', ''), '/', '.', 'g')")
                              "}}}
                              " Initialize filename include extensions. "{{{
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'c', ['h'])
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'cpp', ['', 'h', 'hpp', 'hxx'])
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'perl', ['pm'])
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'java', ['java'])
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'ruby', ['rb'])
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_exts', 'python', ['py', 'py3'])
                              "}}}
                              " Initialize filename include delimiter. "{{{
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_delimiters', 'c,cpp,ruby', '/')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_delimiters', 'html,xhtml,xml,markdown,mkd', '')
                              "}}}
                            
                              " Initialize ctags command. "{{{
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_commands', '_', 'ctags')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_commands', 'go', 'gotags')
                              "}}}
                              " Initialize ctags arguments. "{{{
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_arguments', '_', '')
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_arguments', 'vim', '--language-force=vim --extra=fq --fields=+ailmnSz --vim-kinds=-f '. '--regex-vim=''/function!?[ \t]+'. '(([bwtglsa]:)?\w+(\.\w+)+|(g:)?([A-Z]\w*|\w+(#\w+)+)|s:\w+)'. '[ \t]*\(/\1/function/''')
                              if neoinclude#util#is_mac()
                                call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_arguments', 'c', '--c-kinds=+p --fields=+iaS --extra=+q -I__DARWIN_ALIAS,__DARWIN_ALIAS_C,__DARWIN_ALIAS_I,__DARWIN_INODE64 -I__DARWIN_1050,__DARWIN_1050ALIAS,__DARWIN_1050ALIAS_C,__DARWIN_1050ALIAS_I,__DARWIN_1050INODE64 -I__DARWIN_EXTSN,__DARWIN_EXTSN_C -I__DARWIN_LDBL_COMPAT,__DARWIN_LDBL_COMPAT2')
                              else
                                call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_arguments', 'c', '-R --sort=1 --c-kinds=+p --fields=+iaS --extra=+q ' . '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
                              endif
                              call neoinclude#util#set_default_dictionary( 'g:neoinclude#_ctags_arguments', 'cpp', '--language-force=C++ -R --sort=1 --c++-kinds=+p --fields=+iaS --extra=+q '. '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
                              "}}}
                            
                              augroup neoinclude
                                autocmd!
                              augroup END
                            
                              call neoinclude#include#initialize()
                            
                              let s:initialized = 1

FUNCTION  <SNR>60_on_insert_char_pre()
Called 65 times
Total time:   0.001114
 Self time:   0.001114

count  total (s)   self (s)
   65              0.000766   if !pumvisible() || !g:deoplete#enable_refresh_always || s:is_skip_textwidth(deoplete#util#get_input('InsertCharPre'))
   65              0.000177     return 1
                              endif
                            
                              " Auto refresh
                              call feedkeys("\<Plug>(deoplete_auto_refresh)")

FUNCTION  <SNR>18_get_char()
Called 89 times
Total time:   0.002686
 Self time:   0.002686

count  total (s)   self (s)
   89              0.000269   let idx = col('.') - 1
   89              0.000231   if !a:0 || (a:0 && a:1 >= 0)
                                " Get char from cursor.
   36              0.000137     let line = getline('.')[idx :]
   36              0.000088     let pos = a:0 ? a:1 : 0
   36              0.000284     return matchstr(line, '^'.repeat('.', pos).'\zs.')
                              endif
                              " Get char behind cursor.
   53              0.000234   let line = getline('.')[: idx - 1]
   53              0.000156   let pos = 0 - (1 + a:1)
   53              0.000680   return matchstr(line, '.\ze'.repeat('.', pos).'$')

FUNCTION  <SNR>18_is_cr_expansion()
Called 10 times
Total time:   0.001198
 Self time:   0.000530

count  total (s)   self (s)
   10              0.000062   let nchar = getline(line('.')-1)[-1:]
   10              0.000110   let schar = matchstr(getline(line('.')+1), '^\s*\zs\S')
   10              0.000059   let isEmpty = a:0 ? getline('.') =~ '^\s*$' : empty(getline('.'))
   10   0.000641   0.000152   if index(s:get('left_delims'), nchar) > -1 && index(s:get('left_delims'), nchar)    == index(s:get('right_delims'), schar) && isEmpty
                                return 1
                              elseif index(s:get('quotes_list'), nchar) > -1 && index(s:get('quotes_list'), nchar)    == index(s:get('quotes_list'), schar) && isEmpty
                                return 1
                              else
   10              0.000011     return 0
                              endif

FUNCTION  <SNR>18_is_excluded_ft()
Called 26 times
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
   26              0.000207   if !exists("g:delimitMate_excluded_ft")
   26              0.000064     return 0
                              endif
                              return index(split(g:delimitMate_excluded_ft, ','), a:ft, 0, 1) >= 0

FUNCTION  <SNR>60_is_skip_textwidth()
Called 22 times
Total time:   0.000706
 Self time:   0.000706

count  total (s)   self (s)
   22              0.000129   let displaywidth = strdisplaywidth(a:input) + 1
                            
   22              0.000220   if &l:formatoptions =~# '[tca]' && &l:textwidth > 0     && displaywidth >= &l:textwidth
                                if &l:formatoptions =~# '[ta]' || !empty(filter(deoplete#util#get_syn_names(),                  'v:val ==# "Comment"'))
                                  return 1
                                endif
                              endif
   22              0.000120   return !pumvisible() && virtcol('.') != displaywidth

FUNCTION  deoplete#util#vimoption2python_not()
Called 2 times
Total time:   0.001132
 Self time:   0.000044

count  total (s)   self (s)
    2   0.001128   0.000040   return '[^a-zA-Z' . s:vimoption2python(a:option) . ']'

FUNCTION  <SNR>18_is_space_expansion()
Called 10 times
Total time:   0.001982
 Self time:   0.000539

count  total (s)   self (s)
   10              0.000026   if col('.') > 2
   10   0.000400   0.000052     let pchar = s:get_char(-2)
   10   0.000242   0.000048     let nchar = s:get_char(1)
   10   0.000581   0.000110     let isSpaces = (s:get_char(-1)   == s:get_char(0) && s:get_char(-1) == " ")
                            
   10   0.000346   0.000117     if index(s:get('left_delims'), pchar) > -1 && index(s:get('left_delims'), pchar)   == index(s:get('right_delims'), nchar) && isSpaces
                                  return 1
                                elseif index(s:get('quotes_list'), pchar) > -1 && index(s:get('quotes_list'), pchar)   == index(s:get('quotes_list'), nchar) && isSpaces
                                  return 1
                                endif
   10              0.000009   endif
   10              0.000011   return 0

FUNCTION  <SNR>30_Highlight_Matching_Pair()
Called 134 times
Total time:   0.055404
 Self time:   0.055404

count  total (s)   self (s)
                              " Remove any previous match.
  134              0.000664   if exists('w:paren_hl_on') && w:paren_hl_on
   37              0.000111     silent! call matchdelete(3)
   37              0.000076     let w:paren_hl_on = 0
   37              0.000030   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  134              0.000487   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  134              0.000339   let c_lnum = line('.')
  134              0.000272   let c_col = col('.')
  134              0.000157   let before = 0
                            
  134              0.000382   let text = getline(c_lnum)
  134              0.001887   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  134              0.000245   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  134              0.000532     let [c_before, c] = matches[1:2]
  134              0.000086   endif
  134              0.001405   let plist = split(&matchpairs, '.\zs[:,]')
  134              0.000367   let i = index(plist, c)
  134              0.000142   if i < 0
                                " not found, in Insert mode try character before the cursor
   98              0.000305     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   86              0.000181       let before = strlen(c_before)
   86              0.000103       let c = c_before
   86              0.000165       let i = index(plist, c)
   86              0.000051     endif
   98              0.000088     if i < 0
                                  " not found, nothing to do
   97              0.000083       return
                                endif
    1              0.000000   endif
                            
                              " Figure out the arguments for searchpairpos().
   37              0.000048   if i % 2 == 0
    1              0.000002     let s_flags = 'nW'
    1              0.000004     let c2 = plist[i + 1]
    1              0.000001   else
   36              0.000050     let s_flags = 'nbW'
   36              0.000049     let c2 = c
   36              0.000090     let c = plist[i - 1]
   36              0.000023   endif
   37              0.000066   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   37              0.000041   if before > 0
    1              0.000003     let has_getcurpos = exists("*getcurpos")
    1              0.000001     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    1              0.000002       let save_cursor = getcurpos()
    1              0.000001     else
                                  let save_cursor = winsaveview()
                                endif
    1              0.000003     call cursor(c_lnum, c_col - before)
    1              0.000001   endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
   37              0.000152   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
   37              0.021667   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
   37              0.000116   let stoplinebottom = line('w$')
   37              0.000087   let stoplinetop = line('w0')
   37              0.000049   if i % 2 == 0
    1              0.000004     let stopline = stoplinebottom
    1              0.000001   else
   36              0.000070     let stopline = stoplinetop
   36              0.000023   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   37              0.000093   if mode() == 'i' || mode() == 'R'
   29              0.000121     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   29              0.000017   else
    8              0.000046     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    8              0.000007   endif
   37              0.000040   try
   37              0.018804     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
   37              0.000062   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
   37              0.000046   if before > 0
    1              0.000001     if has_getcurpos
    1              0.000003       call setpos('.', save_cursor)
    1              0.000001     else
                                  call winrestview(save_cursor)
                                endif
    1              0.000001   endif
                            
                              " If a match is found setup match highlighting.
   37              0.000097   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   37              0.000083     if exists('*matchaddpos')
   37              0.000333       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
   37              0.000024     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
   37              0.000061     let w:paren_hl_on = 1
   37              0.000020   endif

FUNCTION  delimitMate#BS()
Called 10 times
Total time:   0.011392
 Self time:   0.000775

count  total (s)   self (s)
   10   0.006395   0.000200   if s:is_forbidden("")
                                let extra = ''
                              elseif &bs !~ 'start\|2'
                                let extra = ''
                              elseif delimitMate#WithinEmptyPair()
                                let extra = "\<Del>"
                              elseif s:is_space_expansion()
                                let extra = "\<Del>"
                              elseif s:is_cr_expansion()
                                let extra = repeat("\<Del>", len(matchstr(getline(line('.') + 1), '^\s*\S')))
                              else
   10              0.000018     let extra = ''
   10              0.000009   endif
   10              0.000034   return "\<BS>" . extra

FUNCTION  <SNR>45_AddJobinfoForCurrentWin()
Called 2 times
Total time:   0.000109
 Self time:   0.000068

count  total (s)   self (s)
                                " Add jobinfo to current window.
    2              0.000008     let tabpagenr = tabpagenr()
    2              0.000005     let winnr = winnr()
    2   0.000070   0.000029     let win_jobs = s:gettabwinvar(tabpagenr, winnr, 'neomake_jobs', [])
    2              0.000007     let win_jobs += [a:job_id]
    2              0.000014     call settabwinvar(tabpagenr, winnr, 'neomake_jobs', win_jobs)

FUNCTION  delimitMate#QuoteDelim()
Called 1 time
Total time:   0.001046
 Self time:   0.000147

count  total (s)   self (s)
    1   0.000640   0.000011   if s:is_forbidden(a:char)
                                return a:char
                              endif
    1   0.000040   0.000007   let char_at = s:get_char(0)
    1   0.000044   0.000007   let char_before = s:get_char(-1)
    1   0.000031   0.000008   let nesting_on = index(s:get('nesting_quotes'), a:char) > -1
    1              0.000005   let left_q = nesting_on ? s:lquote(a:char) : 0
    1              0.000002   if nesting_on && left_q > 1
                                " Nesting quotes.
                                let right_q =  s:rquote(a:char)
                                let quotes = right_q > left_q + 1 ? 0 : left_q - right_q + 2
                                let lefts = quotes - 1
                                return repeat(a:char, quotes) . repeat(s:joinUndo() . "\<Left>", lefts)
                              elseif char_at == a:char
                                " Inside an empty pair, jump out
                                return a:char . "\<Del>"
                              elseif a:char == '"' && index(split(&ft, '\.'), "vim") != -1 && getline('.') =~ '^\s*$'
                                " If we are in a vim file and it looks like we're starting a comment, do
                                " not add a closing char.
                                return a:char
                              elseif s:is_smart_quote(a:char)
                                " Seems like a smart quote, insert a single char.
                                return a:char
                              elseif (char_before == a:char && char_at != a:char) && !empty(s:get('smart_quotes'))
                                " Seems like we have an unbalanced quote, insert one quotation
                                " mark and jump to the middle.
                                return a:char . s:joinUndo() . "\<Left>"
                              else
                                " Insert a pair and jump to the middle.
    1              0.000001     let sufix = ''
    1   0.000020   0.000006     if !empty(s:get('eol_marker')) && col('.') - 1 == len(getline('.'))
                                  let idx = len(s:get('eol_marker')) * -1
                                  let marker = getline('.')[idx : ]
                                  let has_marker = marker == s:get('eol_marker')
                                  let sufix = !has_marker ? s:get('eol_marker') : ''
                                endif
    1   0.000014   0.000005     return a:char . a:char . s:joinUndo() . "\<Left>"
                              endif

FUNCTION  <SNR>45_CleanJobinfo()
Called 2 times
Total time:   0.000136
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000004     let maker = a:jobinfo.maker
    2   0.000016   0.000007     let maker_key = s:GetMakerKey(maker)
    2              0.000004     if has_key(s:jobs_by_maker, maker_key)
    2              0.000004         unlet s:jobs_by_maker[maker_key]
    2              0.000001     endif
    2              0.000006     call remove(s:jobs, a:jobinfo.id)
                            
                                " Remove job from its window.
    2   0.000059   0.000008     let [t, w] = s:GetTabWinForJob(a:jobinfo.id)
    2   0.000019   0.000007     let jobs = s:gettabwinvar(t, w, 'neomake_jobs', [])
    2              0.000004     let idx = index(jobs, a:jobinfo.id)
    2              0.000002     if idx != -1
    2              0.000004         call remove(jobs, idx)
    2              0.000006         call settabwinvar(t, w, 'neomake_jobs', jobs)
    2              0.000001     endif

FUNCTION  neomake#utils#MakerIsAvailable()
Called 6 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
    6              0.000013     if a:maker_name ==# 'makeprg'
                                    " makeprg refers to the actual makeprg, which we don't need to check
                                    " for our purposes
                                    return 1
                                endif
    6              0.000020     if !has_key(s:available_makers, a:maker_name)
                                    let maker = neomake#GetMaker(a:maker_name, a:ft)
                                    if empty(maker)
                                        return 0
                                    endif
                                    let s:available_makers[a:maker_name] = executable(maker.exe)
                                endif
    6              0.000015     return s:available_makers[a:maker_name]

FUNCTION  neoinclude#util#get_buffer_config()
Called 50 times
Total time:   0.000948
 Self time:   0.000948

count  total (s)   self (s)
   50              0.000165   let default_val = get(a:000, 0, '')
                            
   50              0.000132   if exists(a:buffer_var)
                                return {a:buffer_var}
                              endif
                            
   50              0.000253   let filetype = !has_key(a:user_var, a:filetype) && !has_key(a:default_var, a:filetype) ? '_' : a:filetype
                            
   50              0.000199   return get(a:user_var, filetype,   get(a:default_var, filetype, default_val))

FUNCTION  deoplete#mapping#_set_completeopt()
Called 22 times
Total time:   0.000236
 Self time:   0.000236

count  total (s)   self (s)
   22              0.000094   if exists('g:deoplete#_saved_completeopt')
   20              0.000025     return
                              endif
    2              0.000018   let g:deoplete#_saved_completeopt = &completeopt
    2              0.000022   set completeopt-=longest
    2              0.000009   set completeopt+=menuone
    2              0.000007   set completeopt-=menu
    2              0.000020   if &completeopt !~# 'noinsert\|noselect'
    2              0.000009     set completeopt+=noselect
    2              0.000002   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   94   0.136637   0.012321  neomake#MakeHandler()
    2   0.117978   0.000130  <SNR>45_RegisterJobOutput()
    4   0.117876   0.000177  neomake#ProcessCurrentWindow()
    2   0.076626   0.010460  <SNR>45_ProcessJobOutput()
    2   0.065998   0.008355  <SNR>45_AddExprCallback()
  134   0.055404             <SNR>30_Highlight_Matching_Pair()
   16   0.051598   0.011282  neomake#signs#PlaceVisibleSigns()
    4   0.049912   0.000137  neomake#CleanOldFileSignsAndErrors()
    6   0.049682   0.049209  neomake#signs#CleanOldSigns()
   22   0.041459   0.001416  <SNR>60_completion_delayed()
    4   0.040316   0.040096  neomake#signs#PlaceSign()
   22   0.040043   0.003763  <SNR>60_completion_begin()
   24   0.033790   0.015864  deoplete#init#_context()
   26   0.015580   0.001082  <SNR>18_is_forbidden()
  230   0.012920   0.001363  neomake#utils#DebugMessage()
   26   0.012734             <SNR>18_get_syn_name()
   17   0.012548   0.000979  neomake#CursorMoved()
  232   0.011673             neomake#utils#LogMessage()
   10   0.011392   0.000775  delimitMate#BS()
   26   0.009519   0.005685  <SNR>58_vimoption2python()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  134              0.055404  <SNR>30_Highlight_Matching_Pair()
    6   0.049682   0.049209  neomake#signs#CleanOldSigns()
    4   0.040316   0.040096  neomake#signs#PlaceSign()
   24   0.033790   0.015864  deoplete#init#_context()
   26              0.012734  <SNR>18_get_syn_name()
   94   0.136637   0.012321  neomake#MakeHandler()
  232              0.011673  neomake#utils#LogMessage()
   16   0.051598   0.011282  neomake#signs#PlaceVisibleSigns()
    2   0.076626   0.010460  <SNR>45_ProcessJobOutput()
    2   0.065998   0.008355  <SNR>45_AddExprCallback()
   50              0.006597  deoplete#util#uniq()
   26   0.009519   0.005685  <SNR>58_vimoption2python()
    6   0.004726   0.004579  <SNR>85_check_buffer()
   70              0.004483  deoplete#util#get_input()
   22   0.040043   0.003763  <SNR>60_completion_begin()
  158              0.003648  <SNR>18_get()
    2   0.003629   0.003253  <SNR>45_MakeJob()
   70              0.003046  deoplete#util#get_buffer_config()
   89              0.002686  <SNR>18_get_char()
   22   0.003541   0.001682  neoinclude#file_include#get_complete_position()

